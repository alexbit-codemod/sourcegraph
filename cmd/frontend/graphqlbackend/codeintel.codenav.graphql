extend interface TreeEntry {
    """
    LSIF data for this tree entry.
    """
    lsif(
        """
        An optional filter for the name of the tool that produced the upload data.
        """
        toolName: String
    ): TreeEntryLSIFData
}

extend type GitTree {
    """
    LSIF data for this tree entry.
    """
    lsif(
        """
        An optional filter for the name of the tool that produced the upload data.
        """
        toolName: String
    ): GitTreeLSIFData
}

extend type GitBlob {
    """
    A wrapper around LSIF query methods. If no LSIF upload can be used to answer code
    intelligence queries for this path-at-revision, this resolves to null.
    """
    lsif(
        """
        An optional filter for the name of the tool that produced the upload data.
        """
        toolName: String
    ): GitBlobLSIFData

    """
    Provides code intelligence within the file.

    Experimental: This API is likely to change in the future.
    """
    localCodeIntel: JSONValue

    """
    A wrapper around syntactic hover and definition query methods.

    Experimental: This API is likely to change in the future.
    """
    symbolInfo(line: Int!, character: Int!): SymbolInfo

    """
    Return the code graph data associated with this blob.

    If there are multiple tools (i.e. name and version pairs) which
    have uploaded precise indexes for this blob, then this API will
    return multiple results even if
    filter == { provenance: { equals: Precise } }.
    """
    codeGraphData(filter: CodeGraphDataFilter): [CodeGraphData!]
}

input CodeGraphDataFilter {
    """
    If provenance is not provided, then the API will go through
    each provenance one by one in the order Precise -> Syntactic -> SearchBased
    and stop when some data is available.
    """
    provenance: CodeGraphDataProvenanceComparator
    # EXTENSION: We can add filters for tool name (if there are overlay-style
    # indexers) and build identifier (e.g. Linux vs Windows) here.
}

"""
Invariants:
1. forall sym in symbols.
     (sym.provenance, sym.dataSource) == (scipDocument.provenance, scipDocument.dataSource)
"""
# Implementation notes:
# 1. For precise code nav, we already have a code for inferring
#    'visible uploads' using the commit graph machinery -> infer best upload
#    -> get document for that using the given path.
# 2. Syntactic will be similar to precise
# 3. Search-based -> return empty document/lists.
#
# Ref panel logic:
# 1. Request code graph data, specifying 'filter' if needed.
#    Either the scipDocument or occurrences is fine.
# 2. When a hover is triggered, attempt to look up occurrence in document or list
#    of occurrences (or some other lookup structure constructed from those)
#    based on the source range.
# 3a. If one matching occurrence is found, use SCIPOccurrence.symbol and range to call
#     usagesForSymbol.
# 3b. If zero matching occurrences are found, use only range to call usagesForSymbol.
# 3c. If more than one matching occurrence is found, use some more complex logic
#     to offer a symbol picker.
#     - Problem: For a symbol picker, ideally you'd use SymbolInformation.display_name
#       in SCIP. However, display_name is not supported today by most SCIP indexers.
#       And we don't have any API for getting the detailed SCIP SymbolInformation
#       for a bunch of occurrences.
type CodeGraphData {
    scipDocument: AssociatedSCIPDocument

    """
    The commit associated with this code graph data.

    In general, this will be an ancestor of the commit at which code
    graph data was requested, as code graph data may not be available
    at the exact commit for the blob.
    """
    commit: String!

    """
    Information about the tool which generated this code graph data
    """
    toolInfo: CodeGraphToolInfo

    """
    List of symbols with definitions in this document.

    Invariant:
    forall sym in symbols.
        exists occ in occurrences such that
            sym.name == occ.symbol && occ.roles.contains(Definition)

    These map 1-1 with the symbols in scipDocument.data
    """
    symbols: SymbolInformationConnection

    """
    Occurrences are guaranteed to be sorted by range.
    """
    occurrences(filter: SCIPOccurrencesFilter): SCIPOccurrenceConnection

    # EXTENSION: We can add a build identifier here to return different
    # Documents for (say) Linux vs Windows.
    # EXTENSION: We can add a fileSymbolInfo field here to allow 'Find usages' for the document.
}

type CodeGraphToolInfo {
    name: String
    version: String
}

type SymbolInformationConnection {
    nodes: [SymbolInformation!]
    pageInfo: PageInfo!
}

type SCIPOccurrenceConnection {
    """
    A list of occurrences within a Document
    """
    nodes: [SCIPOccurrence!]

    """
    Pagination information.
    """
    pageInfo: PageInfo!
}

type SCIPOccurrence {
    """
    Symbol name using syntax specified by the SCIP schema.
    https://github.com/sourcegraph/scip/blob/main/scip.proto#L147-L188

    This value will generally be used in conjunction with
    the `usagesBySymbol` API.
    """
    symbol: String
    range: Range!
    roles: [SymbolRole!]
    # EXTENSION: We can add diagnostics etc. here in the future if needed.
}

input SCIPOccurrencesFilter {
    rangeFilter: RangeFilter
    rolesFilter: RolesFilter
    # EXTENSION: We can add a DiagnosticsFilter etc. here in the future if needed.
}

input RangeFilter {
    """
    Zero-based line number, inclusive.
    """
    startLine: Int
    """
    Zero-based line number, inclusive.
    """
    endLine: Int
}

input RolesFilter {
    or: [RolesFilter!]
    equals: SymbolRole
}

enum SymbolRole {
    Definition,
    Reference,
    """
    Applicable for forward declarations in languages with header files (C, C++ etc.)
    as well as standalone signatures in languages with separate interface files (OCaml etc.).
    """
    ForwardDefinition,
}

"""
LSIF data available for a tree entry (file OR directory, see GitBlobLSIFData for file-specific
resolvers and GitTreeLSIFData for directory-specific resolvers.)
"""
interface TreeEntryLSIFData {
    """
    Code diagnostics provided through LSIF.
    """
    diagnostics(first: Int): DiagnosticConnection!
}

"""
A wrapper object around LSIF query methods for a particular git-tree-at-revision. When this node is
null, no LSIF data is available for the git tree in question.
"""
type GitTreeLSIFData implements TreeEntryLSIFData {
    """
    Code diagnostics provided through LSIF.
    """
    diagnostics(first: Int): DiagnosticConnection!
}

"""
A wrapper object around LSIF query methods for a particular git-blob-at-revision. When this node is
null, no LSIF data is available for the git blob in question.
"""
type GitBlobLSIFData implements TreeEntryLSIFData {
    """
    Return a flat list of all ranges in the document that have code intelligence.
    """
    stencil: [Range!]!

    """
    Get aggregated local code intelligence for all ranges that fall in the window
    indicated by the given zero-based start (inclusive) and end (exclusive) lines.
    The associated data for each range is "local", in that the locations and hover
    must also be defined in the same index as the source range. To get cross-repository
    and cross-bundle results, you must query the definitions, references, and hovers
    of that range explicitly.
    """
    ranges(startLine: Int!, endLine: Int!): CodeIntelligenceRangeConnection

    """
    A list of definitions of the symbol under the given document position.
    """
    definitions(
        """
        The line on which the symbol occurs (zero-based, inclusive).
        """
        line: Int!

        """
        The character (not byte) of the start line on which the symbol occurs (zero-based, inclusive).
        """
        character: Int!

        """
        When specified, it filters references by filename.
        """
        filter: String
    ): LocationConnection! @deprecated(reason: "Superseded by usagesForSymbol; use the Definition filter")

    """
    A list of references of the symbol under the given document position.
    """
    references(
        """
        The line on which the symbol occurs (zero-based, inclusive).
        """
        line: Int

        """
        The character (not byte) of the start line on which the symbol occurs (zero-based, inclusive).
        """
        character: Int

        """
        When specified, indicates that this request should be paginated and
        to fetch results starting at this cursor.
        A future request can be made for more results by passing in the
        'LocationConnection.pageInfo.endCursor' that is returned.
        """
        after: String

        """
        When specified, indicates that this request should be paginated and
        the first N results (relative to the cursor) should be returned. i.e.
        how many results to return per page.
        """
        first: Int

        """
        When specified, it filters references by filename.
        """
        filter: String
    ): LocationConnection! @deprecated(reason: "Superseded by usagesForSymbol; use the Reference filter")

    """
    A list of implementations of the symbol under the given document position.
    """
    implementations(
        """
        The line on which the symbol occurs (zero-based, inclusive).
        """
        line: Int!

        """
        The character (not byte) of the start line on which the symbol occurs (zero-based, inclusive).
        """
        character: Int!

        """
        When specified, indicates that this request should be paginated and
        to fetch results starting at this cursor.
        A future request can be made for more results by passing in the
        'LocationConnection.pageInfo.endCursor' that is returned.
        """
        after: String

        """
        When specified, indicates that this request should be paginated and
        the first N results (relative to the cursor) should be returned. i.e.
        how many results to return per page.
        """
        first: Int

        """
        When specified, it filters implementation by filename.
        """
        filter: String
    ): LocationConnection! @deprecated(reason: "Superseded by usagesForSymbol; use the Implemention filter")

    """
    A list of prototypes of the symbol under the given document position.
    """
    prototypes(
        """
        The line on which the symbol occurs (zero-based, inclusive).
        """
        line: Int!

        """
        The character (not byte) of the start line on which the symbol occurs (zero-based, inclusive).
        """
        character: Int!

        """
        When specified, indicates that this request should be paginated and
        to fetch results starting at this cursor.
        A future request can be made for more results by passing in the
        'LocationConnection.pageInfo.endCursor' that is returned.
        """
        after: String

        """
        When specified, indicates that this request should be paginated and
        the first N results (relative to the cursor) should be returned. i.e.
        how many results to return per page.
        """
        first: Int

        """
        When specified, it filters prototypes by filename.
        """
        filter: String
    ): LocationConnection! @deprecated(reason: "Superseded by usagesForSymbol; use the Super filter")

    """
    The hover result of the symbol under the given document position.
    """
    hover(
        """
        The line on which the symbol occurs (zero-based, inclusive).
        """
        line: Int!

        """
        The character (not byte) of the start line on which the symbol occurs (zero-based, inclusive).
        """
        character: Int!
    ): Hover

    """
    Code diagnostics provided through LSIF.
    """
    diagnostics(first: Int): DiagnosticConnection!

    """
    The indexes that could provide precise code intelligence for the current blob.
    """
    visibleIndexes: [PreciseIndex!]

    """
    SCIP snapshot data (similar to the additional information from the `scip snapshot` command) for each SCIP Occurrence.
    """
    snapshot(indexID: ID!): [SnapshotData!]
}

extend type Query {
    """
    Identify usages for either a semantic symbol, or the symbol(s) implied
    by a source range.

    Ordering and uniqueness guarantees:
    1. The usages returned will already be de-duplicated.
    2. Results for a single file are contiguous.
    3. Results for a single repository are contiguous.

    Related: See `codeGraphData` on GitBlob.
    """
    usagesForSymbol(
        """
        Symbol to perform the lookup for.

        If provided, then the start and end position in `range` are optional.

        If not provided, and if multiple symbols are detected at the same range,
        the combined results for all symbols will be returned.
        In that case, `Usage.symbol.name` can be used to group results.
        """
        symbol: SymbolComparator,

        """
        Information about an existing source range for a usage of the symbol.

        TODO: Specify behavior for various cases of overlap between LookupRange
        and actual occurrence range.
        """
        range: RangeInput!,

        filter: UsagesFilter,

        """
        When specified, indicates that this request should be paginated and
        the first N results (relative to the cursor) should be returned. i.e.
        how many results to return per page.
        """
        first: Int

        """
        When specified, indicates that this request should be paginated and
        to fetch results starting at this cursor.
        A future request can be made for more results by passing in the
        'UsageConnection.pageInfo.endCursor' that is returned.
        """
        after: String
    ): UsageConnection!
}

input SymbolComparator {
    name: SymbolNameComparator!
    provenance: CodeGraphDataProvenanceComparator!
}

# Implementation note: In the future, we may want to extend this
# to allow passing in a suffix or a "symbol pattern".
# See https://github.com/sourcegraph/sourcegraph/issues/59957
input SymbolNameComparator {
    equals: String
}

input CodeGraphDataProvenanceComparator {
    equals: CodeGraphDataProvenance
}

"""
Type representing useful information about a symbol in code,
based on 'SymbolInformation' in SCIP.
"""
type SymbolInformation {
    """
    Symbol name using syntax specified by the SCIP schema.
    https://github.com/sourcegraph/scip/blob/main/scip.proto#L147-L188

    This value will generally be used in conjunction with
    the `usagesBySymbol` API.
    """
    name: String!

    """
    Hover documentation for the symbol, in Markdown format.

    The caller must take care to escape any particular strings,
    such as raw HTML, as necessary.

    The value is null when the hover documentation is not found
    by 'dataSource'.

    The value is empty when `dataSource` is confident that there
    is no appropriate hover documentation to display.
    """
    documentation: [String!]

    """
    Coarse-grained information about the data source.
    """
    provenance: CodeGraphDataProvenance!

    """
    Opaque fine-grained information describing the data source.

    Provided only for debugging.

    This field should be ignored when checking structural equality.
    """
    dataSource: String
}

input RangeInput {
    """
    Defaults to instance-wide search if the repo is not specified.

    This field is necessary if SymbolComparator is a repository-local or
    file-local symbol. It is mandatory for cross-repository symbols
    due to implementation limitations.
    """
    repository: String!

    """
    Defaults to HEAD of the default branch if not specified.
    """
    revision: String

    """
    Defaults to repo-wide search if the path is not specified.

    This field is necessary if SymbolComparator is a file-local symbol.
    It is mandatory for repository-local and cross-repo symbols
    due to implementation limitations.
    """
    path: String!

    start: PositionInput

    end: PositionInput
}

input PositionInput {
    """
    Zero-based count of newline (\n or \r\n) characters before this position.
    """
    line: Int!

    """
    Zero-based UTF-16 code unit offset from preceding newline (\n or \r\n) character.
    """
    character: Int!
}

# NOTE(id: filter-vs-comparator-terminology)
#
# 'Filter' is used for complex objects whereas 'Comparator' is used
# for primitive objects.

"""
An empty filter allows all kinds of usages for all paths in all repositories.

However, if the symbol used for lookup is a file-local symbol or a
repository-local symbol, then usages will automatically be limited to the
same file or same repository respectively.

Filters are combined monoidally, i.e. all filters are applied. For example,

```
{and: [u1, u2], or: [u3, u4], not: u5}
```

would be equivalent to:

```
{and: [{and: [u1, u2]}, {or: [u3, u4]}, {not: u5}]}
```
"""
# Design Rationale:
#
# 1. The ref panel did separate queries for 'this repo' vs 'all other repos'
#    https://sourcegraph.com/github.com/sourcegraph/sourcegraph/-/blob/client/web/src/enterprise/codeintel/searchBased.ts?L105:13-105:23#tab=references
#    That requires `NOT` (at least for a `repo`).
# 2. The ref panel has a way to specify paths for filtering. This requires AND.
#    AND will not be part of the first implementation pass. However,
#    it would allow fetching less data instead of post-filtering client-side.
# 3. Currently, the ref panel has a setting for only showing precise results.
#    Once syntactic is added, if we want to allow the user to specify either
#    syntactic or precise (but not search-based), we'd need OR.
#    OR will also not be needed for the first implementation pass.
input UsagesFilter {
    and: [UsagesFilter!]
    or: [UsagesFilter!]
    not: UsagesFilter
    repository: RepositoryFilter
    path: PathFilter
    kind: SymbolUsageKindComparator
    provenance: CodeGraphDataProvenanceComparator
}

input RepositoryFilter {
    name: StringComparator!
}

input PathFilter {
    name: StringComparator!
}

input StringComparator {
    equals: String
}

input SymbolUsageKindComparator {
    equals: SymbolUsageKind
}

enum SymbolUsageKind {
    Definition,

    Reference,

    """
    If a type T implements an interface X or inherits from another type X,
    then searching for Implementations of X will return T as a result
    if the data source supports it.
    """
    Implementation,

    """
    If a type T implements an interface X or inherits from another type X,
    then searching for Supers of T will return X as a result
    if the data source supports it.
    """
    Super,
}

type UsageConnection {
    nodes: [Usage!]!
    pageInfo: PageInfo!
}

type UsageRange {
    repository: String!
    revision: String!
    path: String!
    range: Range!
}

type Usage {
    symbol: SymbolInformation!

    """
    Invariant: `range.path` == `blob.path`. The path is made available
    as part of this type for convenience.
    """
    range: UsageRange

    """
    Instead of requesting `blob.content`, it may be more useful
    to ask for `surroundingBlobContent`.
    """
    # Left as optional in case we support generated files in the future,
    # which may not be represented by GitBlob.
    blob: GitBlob

    """
    Instead of blob { content }, allows accessing a sub-span of the content
    using relative coordinates from the range of this usage. If linesBefore
    or linesAfter is negative or exceeds the number of available lines,
    the value is interpreted as until the start/end of the file.
    """
    surroundingContent(surroundingLines: SurroundingLines = {linesBefore: 0, linesAfter: 0}): String
}

input SurroundingLines {
    linesBefore: Int
    linesAfter: Int
}

"""
The SCIP snapshot decoration for a single SCIP Occurrence.
"""
type SnapshotData {
    """
    The byte offset in the document immediately after the line the occurrence is on.
    """
    offset: Int!
    """
    The formatted SCIP symbol string.
    """
    data: String!

    """
    Any additional lines of snapshot output such as relationships, documentation etc.
    """
    additional: [String!]
}

"""
Aggregate local code intelligence for all ranges that fall between a window of lines in a document.
"""
type CodeIntelligenceRangeConnection {
    """
    Aggregate local code intelligence grouped by range.
    """
    nodes: [CodeIntelligenceRange!]!
}

"""
Aggregate code intelligence for a particular range within a document.
"""
type CodeIntelligenceRange {
    """
    The range this code intelligence applies to.
    """
    range: Range!

    """
    A list of definitions of the symbol occurring within the range.
    """
    definitions: LocationConnection!

    """
    A list of references of the symbol occurring within the range.
    """
    references: LocationConnection!

    """
    A list of implementations of the symbol occurring within the range.
    """
    implementations: LocationConnection!

    """
    The hover result of the symbol occurring within the range.
    """
    hover: Hover
}

"""
Hover range and markdown content.
"""
type Hover {
    """
    A markdown string containing the contents of the hover.
    """
    markdown: Markdown!

    """
    The range to highlight.
    """
    range: Range!
}

"""
A list of diagnostics.
"""
type DiagnosticConnection {
    """
    A list of diagnostics.
    """
    nodes: [Diagnostic!]!

    """
    The total count of diagnostics (which may be larger than nodes.length if the connection is paginated).
    """
    totalCount: Int

    """
    Pagination information.
    """
    pageInfo: PageInfo!
}

"""
Represents a diagnostic, such as a compiler error or warning.
"""
type Diagnostic {
    """
    The location at which the message applies.
    """
    location: Location!

    """
    The diagnostic's severity.
    """
    severity: DiagnosticSeverity

    """
    The diagnostic's code as provided by the tool.
    """
    code: String

    """
    A human-readable string describing the source of this
    diagnostic, e.g. "typescript" or "super lint".
    """
    source: String

    """
    The diagnostic's message.
    """
    message: String
}

"""
Represents the severity level of a diagnostic.
"""
enum DiagnosticSeverity {
    ERROR
    WARNING
    INFORMATION
    HINT
}

"""
SymbolInfo contains hover and definition methods. It's returned by GitBlob.symbolInfo(line, character).
"""
type SymbolInfo {
    """
    The definition of the symbol.
    """
    definition: SymbolLocation

    """
    The hover for the symbol.
    """
    hover: String
}

"""
SymbolLocation is a single-line range within a repository. It's returned by SymbolInfo.definition.
"""
type SymbolLocation {
    """
    The repo.
    """
    repo: String!

    """
    The commit.
    """
    commit: String!

    """
    The path.
    """
    path: String!

    """
    The range.
    """
    range: LineRange

    """
    The line.
    """
    line: Int! @deprecated(reason: "use range.line instead")

    """
    The character.
    """
    character: Int! @deprecated(reason: "use range.character instead")

    """
    The length.
    """
    length: Int! @deprecated(reason: "use range.length instead")
}

"""
LineRange is a span within a line.
"""
type LineRange {
    """
    The line.
    """
    line: Int!

    """
    The character.
    """
    character: Int!

    """
    The length.
    """
    length: Int!
}
