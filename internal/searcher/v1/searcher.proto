syntax = "proto3";

package searcher.v1;

import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";

option go_package = "github.com/sourcegraph/sourcegraph/internal/searcher/v1";

// SearcherService is an internal interface for the searcher service.
service SearcherService {
  // Search executes a search, streaming back its results
  rpc Search(SearchRequest) returns (stream SearchResponse) {
    option idempotency_level = IDEMPOTENT;
  }
  rpc CommitSearch(CommitSearchRequest) returns (stream CommitSearchResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
}

// SearchRequest is set of parameters for a search.
message SearchRequest {
  reserved 9;

  // repo is the name of the repo to search (e.g. "github.com/gorilla/mux")
  string repo = 1;

  // repo_id is the Sourcegraph repository ID of the repo to search
  uint32 repo_id = 2;

  // commit_oid is the 40-character commit hash for the commit to be searched.
  // It is required to be resolved, not a ref like HEAD or master.
  string commit_oid = 3;

  // indexed is whether the revision to be searched is indexed or
  // unindexed. This matters for structural search because it will query
  // Zoekt for indexed structural search.
  bool indexed = 4;

  PatternInfo pattern_info = 5;

  // URL specifies the repository's Git remote URL (for gitserver). It is
  // optional. See (gitserver.ExecRequest).URL for documentation on what it is
  // used for.
  string url = 6;

  // branch is used for structural search as an alternative to Commit
  // because Zoekt only takes branch names
  string branch = 7;

  // fetch_timeout is the amount of time to wait for a repo archive to
  // fetch.
  //
  // This timeout should be low when searching across many repos so that
  // unfetched repos don't delay the search, and because we are likely
  // to get results from the repos that have already been fetched.
  //
  // This timeout should be high when searching across a single repo
  // because returning results slowly is better than returning no
  // results at all.
  //
  // This only times out how long we wait for the fetch request; the
  // fetch will still happen in the background so future requests don't
  // have to wait.
  google.protobuf.Duration fetch_timeout = 8;

  // num_context_lines is the number of additional lines of context
  // (before and after the matched lines) to return with the match.
  int32 num_context_lines = 10;
}

// SearchResponse is a message in the response stream for Search
message SearchResponse {
  // Done is the final SearchResponse message sent in the stream
  // of responses to Search.
  message Done {
    bool limit_hit = 1;
    reserved 2;
  }

  oneof message {
    FileMatch file_match = 1;
    Done done_message = 2;
  }
}

// FileMatch is a file that matched the search query along
// with the parts of the file that matched.
message FileMatch {
  // The file's path
  bytes path = 1;

  // A list of matched chunks
  repeated ChunkMatch chunk_matches = 2;

  // Whether the limit was hit while searching this
  // file. Indicates that the results for this file
  // may not be complete.
  bool limit_hit = 3;

  // The file's detected language
  bytes language = 4;
}

// ChunkMatch is a matched chunk of a file.
message ChunkMatch {
  // The raw content that contains the match. Will always
  // contain complete lines.
  bytes content = 1;

  // The location relative to the start of the file
  // where the chunk content starts.
  Location content_start = 2;

  // A list of ranges within the chunk content that match
  // the search query.
  repeated Range ranges = 3;
}

message Range {
  Location start = 1;
  Location end = 2;
}

// A location represents an offset within a file.
message Location {
  // The byte offset from the beginning of the byte slice.
  int32 offset = 1;
  // The number of newlines in the file before the offset.
  int32 line = 2;
  // The rune offset from the beginning of the last line.
  int32 column = 3;
}

message QueryNode {
  oneof value {
    PatternNode pattern = 1;
    AndNode and = 2;
    OrNode or = 3;
  }
}

// PatternNode represents a leaf query against a specific pattern
message PatternNode {
  // value is the search query. It is a regular expression if IsRegExp
  // is true, otherwise a fixed string.
  string value = 1;

  // is_negated if true will invert the matching logic for regexp searches.
  // Structural searches do not support negation.
  bool is_negated = 2;

  // is_regexp if true will treat the pattern as a regular expression.
  bool is_regexp = 3;
}

message AndNode {
  repeated QueryNode children = 1;
}

message OrNode {
  repeated QueryNode children = 1;
}

message PatternInfo {
  reserved 1, 2, 3, 5;

  // is_structural if true will treat the pattern as a Comby structural search
  // pattern.
  bool is_structural = 4;

  // is_case_sensitive if false will ignore the case of text and pattern
  // when finding matches.
  bool is_case_sensitive = 6;

  // exclude_pattern is a pattern that may not match the returned files' paths.
  // eg '**/node_modules'
  string exclude_pattern = 7;

  // include_patterns is a list of patterns that must *all* match the returned
  // files' paths.
  // eg '**/node_modules'
  //
  // The patterns are ANDed together; a file's path must match all patterns
  // for it to be kept. That is also why it is a list (unlike the singular
  // ExcludePattern); it is not possible in general to construct a single
  // glob or Go regexp that represents multiple such patterns ANDed together.
  repeated string include_patterns = 8;

  // path_patterns_are_case_sensitive indicates that exclude_pattern and
  // include_patterns are case sensitive.
  bool path_patterns_are_case_sensitive = 9;

  // limit is the cap on the total number of matches returned.
  // A match is either a path match, or a fragment of a line matched by the
  // query.
  int64 limit = 10;

  // pattern_matches_content is whether the pattern should be matched
  // against the content of files.
  bool pattern_matches_content = 11;

  // pattern_matches_content is whether a file whose path matches
  // pattern (but whose contents don't) should be considered a match.
  bool pattern_matches_path = 12;

  // comby_rule is a rule that constrains matching for structural search.
  // It only applies when IsStructuralPat is true.
  // As a temporary measure, the expression `where "backcompat" == "backcompat"`
  // acts as a flag to activate the old structural search path, which queries
  // zoekt for the file list in the frontend and passes it to searcher.
  string comby_rule = 13;

  // languages is the list of languages passed via the lang filters (e.g.,
  // "lang:c") and is used for structural search
  repeated string languages = 14;

  // select is the value of the the select field in the query. It is not
  // necessary to use it since selection is done after the query completes, but
  // exposing it can enable optimizations.
  string select = 15;

  // query defines the query to match files against. It supports regexp
  // patterns optionally combined through boolean operators.
  QueryNode query = 16;

  // include_langs and exclude_langs represent the languages to filter on
  repeated string include_langs = 17;
  repeated string exclude_langs = 18;
}

message CommitSearchRequest {
  // repo is the name of the repo to be searched
  string repo = 1;
  // revisions is the list of git revision to be searched. They are all passed
  // to the same underlying git command, so the searched commits will be the
  // union of all revisions listed.
  repeated RevisionSpecifier revisions = 2;
  // limit is a limit on the number of search results returned. Additional
  // results will be ignored.
  int64 limit = 3;
  // include_diff specifies whether the full diff should be included on the
  // result messages. This can be expensive, so is disabled by default.
  bool include_diff = 4;
  // include_modified specifies whether to include the list of modified files
  // in the search results. This can be expensive, so is disabled by default.
  bool include_modified_files = 5;
  // query is a tree of filters to apply to commits being searched.
  CommitSearchQueryNode query = 6;
}

message RevisionSpecifier {
  // RevSpec is a revision range specifier suitable for passing to git. See
  // the manpage gitrevisions(7).
  string rev_spec = 1;
  reserved 2;
  reserved 3;
}

// AuthorMatchesNode is a predicate that matches if the author's name or email
// address matches the regex pattern.
message AuthorMatchesNode {
  string expr = 1;
  bool ignore_case = 2;
}

// CommitterMatchesNode is a predicate that matches if the author's name or
// email address matches the regex pattern.
message CommitterMatchesNode {
  string expr = 1;
  bool ignore_case = 2;
}

// CommitBeforeNode is a predicate that matches if the commit is before the
// given date
message CommitBeforeNode {
  google.protobuf.Timestamp timestamp = 1;
}

// CommitAfterNode is a predicate that matches if the commit is after the given
// date
message CommitAfterNode {
  google.protobuf.Timestamp timestamp = 1;
}

// MessageMatchesNode is a predicate that matches if the commit message matches
// the provided regex pattern.
message MessageMatchesNode {
  string expr = 1;
  bool ignore_case = 2;
}

// DiffMatchesNode is a a predicate that matches if any of the lines changed by
// the commit match the given regex pattern.
message DiffMatchesNode {
  string expr = 1;
  bool ignore_case = 2;
}

// DiffModifiesFileNode is a predicate that matches if the commit modifies any
// files that match the given regex pattern.
message DiffModifiesFileNode {
  string expr = 1;
  bool ignore_case = 2;
}

// BooleanNode is a predicate that will either always match or never match
message BooleanNode {
  bool value = 1;
}

enum OperatorKind {
  OPERATOR_KIND_UNSPECIFIED = 0;
  OPERATOR_KIND_AND = 1;
  OPERATOR_KIND_OR = 2;
  OPERATOR_KIND_NOT = 3;
}

message CommitSearchOperatorNode {
  OperatorKind kind = 1;
  repeated CommitSearchQueryNode operands = 2;
}

message CommitSearchQueryNode {
  oneof value {
    AuthorMatchesNode author_matches = 1;
    CommitterMatchesNode committer_matches = 2;
    CommitBeforeNode commit_before = 3;
    CommitAfterNode commit_after = 4;
    MessageMatchesNode message_matches = 5;
    DiffMatchesNode diff_matches = 6;
    DiffModifiesFileNode diff_modifies_file = 7;
    BooleanNode boolean = 8;
    CommitSearchOperatorNode operator = 9;
  }
}

message CommitSearchResponse {
  oneof message {
    CommitMatch match = 1;
    bool limit_hit = 2;
  }
}

message CommitMatch {
  message Signature {
    string name = 1;
    string email = 2;
    google.protobuf.Timestamp date = 3;
  }

  message MatchedString {
    string content = 1;
    repeated Range ranges = 2;
  }

  // TODO move this into a shared package
  message Range {
    Location start = 1;
    Location end = 2;
  }

  message Location {
    uint32 offset = 1;
    uint32 line = 2;
    uint32 column = 3;
  }

  // oid is the 40-character, hex-encoded commit hash
  string oid = 1;
  Signature author = 2;
  Signature committer = 3;
  // parents is the list of commit hashes for this commit's parents
  repeated string parents = 4;
  repeated string refs = 5;
  repeated string source_refs = 6;
  // message is the commits message and a list of ranges that match
  // the search query.
  MatchedString message = 7;
  // diff is the diff between this commit and its first parent.
  // May be unset if `include_diff` was not specified in the request.
  MatchedString diff = 8;
  // modified_files is the list of files modified by this commit compared
  // to its first parent. May be unset if `include_modified_files` is not
  // specified in the request.
  repeated string modified_files = 9;
}
