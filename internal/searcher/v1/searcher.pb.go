// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.29.1
// 	protoc        (unknown)
// source: searcher.proto

package v1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type OperatorKind int32

const (
	OperatorKind_OPERATOR_KIND_UNSPECIFIED OperatorKind = 0
	OperatorKind_OPERATOR_KIND_AND         OperatorKind = 1
	OperatorKind_OPERATOR_KIND_OR          OperatorKind = 2
	OperatorKind_OPERATOR_KIND_NOT         OperatorKind = 3
)

// Enum value maps for OperatorKind.
var (
	OperatorKind_name = map[int32]string{
		0: "OPERATOR_KIND_UNSPECIFIED",
		1: "OPERATOR_KIND_AND",
		2: "OPERATOR_KIND_OR",
		3: "OPERATOR_KIND_NOT",
	}
	OperatorKind_value = map[string]int32{
		"OPERATOR_KIND_UNSPECIFIED": 0,
		"OPERATOR_KIND_AND":         1,
		"OPERATOR_KIND_OR":          2,
		"OPERATOR_KIND_NOT":         3,
	}
)

func (x OperatorKind) Enum() *OperatorKind {
	p := new(OperatorKind)
	*p = x
	return p
}

func (x OperatorKind) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (OperatorKind) Descriptor() protoreflect.EnumDescriptor {
	return file_searcher_proto_enumTypes[0].Descriptor()
}

func (OperatorKind) Type() protoreflect.EnumType {
	return &file_searcher_proto_enumTypes[0]
}

func (x OperatorKind) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use OperatorKind.Descriptor instead.
func (OperatorKind) EnumDescriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{0}
}

// SearchRequest is set of parameters for a search.
type SearchRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// repo is the name of the repo to search (e.g. "github.com/gorilla/mux")
	Repo string `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	// repo_id is the Sourcegraph repository ID of the repo to search
	RepoId uint32 `protobuf:"varint,2,opt,name=repo_id,json=repoId,proto3" json:"repo_id,omitempty"`
	// commit_oid is the 40-character commit hash for the commit to be searched.
	// It is required to be resolved, not a ref like HEAD or master.
	CommitOid string `protobuf:"bytes,3,opt,name=commit_oid,json=commitOid,proto3" json:"commit_oid,omitempty"`
	// indexed is whether the revision to be searched is indexed or
	// unindexed. This matters for structural search because it will query
	// Zoekt for indexed structural search.
	Indexed     bool         `protobuf:"varint,4,opt,name=indexed,proto3" json:"indexed,omitempty"`
	PatternInfo *PatternInfo `protobuf:"bytes,5,opt,name=pattern_info,json=patternInfo,proto3" json:"pattern_info,omitempty"`
	// URL specifies the repository's Git remote URL (for gitserver). It is
	// optional. See (gitserver.ExecRequest).URL for documentation on what it is
	// used for.
	Url string `protobuf:"bytes,6,opt,name=url,proto3" json:"url,omitempty"`
	// branch is used for structural search as an alternative to Commit
	// because Zoekt only takes branch names
	Branch string `protobuf:"bytes,7,opt,name=branch,proto3" json:"branch,omitempty"`
	// fetch_timeout is the amount of time to wait for a repo archive to
	// fetch.
	//
	// This timeout should be low when searching across many repos so that
	// unfetched repos don't delay the search, and because we are likely
	// to get results from the repos that have already been fetched.
	//
	// This timeout should be high when searching across a single repo
	// because returning results slowly is better than returning no
	// results at all.
	//
	// This only times out how long we wait for the fetch request; the
	// fetch will still happen in the background so future requests don't
	// have to wait.
	FetchTimeout *durationpb.Duration `protobuf:"bytes,8,opt,name=fetch_timeout,json=fetchTimeout,proto3" json:"fetch_timeout,omitempty"`
	// num_context_lines is the number of additional lines of context
	// (before and after the matched lines) to return with the match.
	NumContextLines int32 `protobuf:"varint,10,opt,name=num_context_lines,json=numContextLines,proto3" json:"num_context_lines,omitempty"`
}

func (x *SearchRequest) Reset() {
	*x = SearchRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SearchRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchRequest) ProtoMessage() {}

func (x *SearchRequest) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchRequest.ProtoReflect.Descriptor instead.
func (*SearchRequest) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{0}
}

func (x *SearchRequest) GetRepo() string {
	if x != nil {
		return x.Repo
	}
	return ""
}

func (x *SearchRequest) GetRepoId() uint32 {
	if x != nil {
		return x.RepoId
	}
	return 0
}

func (x *SearchRequest) GetCommitOid() string {
	if x != nil {
		return x.CommitOid
	}
	return ""
}

func (x *SearchRequest) GetIndexed() bool {
	if x != nil {
		return x.Indexed
	}
	return false
}

func (x *SearchRequest) GetPatternInfo() *PatternInfo {
	if x != nil {
		return x.PatternInfo
	}
	return nil
}

func (x *SearchRequest) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *SearchRequest) GetBranch() string {
	if x != nil {
		return x.Branch
	}
	return ""
}

func (x *SearchRequest) GetFetchTimeout() *durationpb.Duration {
	if x != nil {
		return x.FetchTimeout
	}
	return nil
}

func (x *SearchRequest) GetNumContextLines() int32 {
	if x != nil {
		return x.NumContextLines
	}
	return 0
}

// SearchResponse is a message in the response stream for Search
type SearchResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Message:
	//
	//	*SearchResponse_FileMatch
	//	*SearchResponse_DoneMessage
	Message isSearchResponse_Message `protobuf_oneof:"message"`
}

func (x *SearchResponse) Reset() {
	*x = SearchResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SearchResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchResponse) ProtoMessage() {}

func (x *SearchResponse) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchResponse.ProtoReflect.Descriptor instead.
func (*SearchResponse) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{1}
}

func (m *SearchResponse) GetMessage() isSearchResponse_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (x *SearchResponse) GetFileMatch() *FileMatch {
	if x, ok := x.GetMessage().(*SearchResponse_FileMatch); ok {
		return x.FileMatch
	}
	return nil
}

func (x *SearchResponse) GetDoneMessage() *SearchResponse_Done {
	if x, ok := x.GetMessage().(*SearchResponse_DoneMessage); ok {
		return x.DoneMessage
	}
	return nil
}

type isSearchResponse_Message interface {
	isSearchResponse_Message()
}

type SearchResponse_FileMatch struct {
	FileMatch *FileMatch `protobuf:"bytes,1,opt,name=file_match,json=fileMatch,proto3,oneof"`
}

type SearchResponse_DoneMessage struct {
	DoneMessage *SearchResponse_Done `protobuf:"bytes,2,opt,name=done_message,json=doneMessage,proto3,oneof"`
}

func (*SearchResponse_FileMatch) isSearchResponse_Message() {}

func (*SearchResponse_DoneMessage) isSearchResponse_Message() {}

// FileMatch is a file that matched the search query along
// with the parts of the file that matched.
type FileMatch struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The file's path
	Path []byte `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// A list of matched chunks
	ChunkMatches []*ChunkMatch `protobuf:"bytes,2,rep,name=chunk_matches,json=chunkMatches,proto3" json:"chunk_matches,omitempty"`
	// Whether the limit was hit while searching this
	// file. Indicates that the results for this file
	// may not be complete.
	LimitHit bool `protobuf:"varint,3,opt,name=limit_hit,json=limitHit,proto3" json:"limit_hit,omitempty"`
	// The file's detected language
	Language []byte `protobuf:"bytes,4,opt,name=language,proto3" json:"language,omitempty"`
}

func (x *FileMatch) Reset() {
	*x = FileMatch{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FileMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileMatch) ProtoMessage() {}

func (x *FileMatch) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileMatch.ProtoReflect.Descriptor instead.
func (*FileMatch) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{2}
}

func (x *FileMatch) GetPath() []byte {
	if x != nil {
		return x.Path
	}
	return nil
}

func (x *FileMatch) GetChunkMatches() []*ChunkMatch {
	if x != nil {
		return x.ChunkMatches
	}
	return nil
}

func (x *FileMatch) GetLimitHit() bool {
	if x != nil {
		return x.LimitHit
	}
	return false
}

func (x *FileMatch) GetLanguage() []byte {
	if x != nil {
		return x.Language
	}
	return nil
}

// ChunkMatch is a matched chunk of a file.
type ChunkMatch struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The raw content that contains the match. Will always
	// contain complete lines.
	Content []byte `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	// The location relative to the start of the file
	// where the chunk content starts.
	ContentStart *Location `protobuf:"bytes,2,opt,name=content_start,json=contentStart,proto3" json:"content_start,omitempty"`
	// A list of ranges within the chunk content that match
	// the search query.
	Ranges []*Range `protobuf:"bytes,3,rep,name=ranges,proto3" json:"ranges,omitempty"`
}

func (x *ChunkMatch) Reset() {
	*x = ChunkMatch{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ChunkMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChunkMatch) ProtoMessage() {}

func (x *ChunkMatch) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChunkMatch.ProtoReflect.Descriptor instead.
func (*ChunkMatch) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{3}
}

func (x *ChunkMatch) GetContent() []byte {
	if x != nil {
		return x.Content
	}
	return nil
}

func (x *ChunkMatch) GetContentStart() *Location {
	if x != nil {
		return x.ContentStart
	}
	return nil
}

func (x *ChunkMatch) GetRanges() []*Range {
	if x != nil {
		return x.Ranges
	}
	return nil
}

type Range struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Start *Location `protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"`
	End   *Location `protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (x *Range) Reset() {
	*x = Range{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Range) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Range) ProtoMessage() {}

func (x *Range) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Range.ProtoReflect.Descriptor instead.
func (*Range) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{4}
}

func (x *Range) GetStart() *Location {
	if x != nil {
		return x.Start
	}
	return nil
}

func (x *Range) GetEnd() *Location {
	if x != nil {
		return x.End
	}
	return nil
}

// A location represents an offset within a file.
type Location struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The byte offset from the beginning of the byte slice.
	Offset int32 `protobuf:"varint,1,opt,name=offset,proto3" json:"offset,omitempty"`
	// The number of newlines in the file before the offset.
	Line int32 `protobuf:"varint,2,opt,name=line,proto3" json:"line,omitempty"`
	// The rune offset from the beginning of the last line.
	Column int32 `protobuf:"varint,3,opt,name=column,proto3" json:"column,omitempty"`
}

func (x *Location) Reset() {
	*x = Location{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Location) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Location) ProtoMessage() {}

func (x *Location) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Location.ProtoReflect.Descriptor instead.
func (*Location) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{5}
}

func (x *Location) GetOffset() int32 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *Location) GetLine() int32 {
	if x != nil {
		return x.Line
	}
	return 0
}

func (x *Location) GetColumn() int32 {
	if x != nil {
		return x.Column
	}
	return 0
}

type QueryNode struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Value:
	//
	//	*QueryNode_Pattern
	//	*QueryNode_And
	//	*QueryNode_Or
	Value isQueryNode_Value `protobuf_oneof:"value"`
}

func (x *QueryNode) Reset() {
	*x = QueryNode{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *QueryNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryNode) ProtoMessage() {}

func (x *QueryNode) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryNode.ProtoReflect.Descriptor instead.
func (*QueryNode) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{6}
}

func (m *QueryNode) GetValue() isQueryNode_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (x *QueryNode) GetPattern() *PatternNode {
	if x, ok := x.GetValue().(*QueryNode_Pattern); ok {
		return x.Pattern
	}
	return nil
}

func (x *QueryNode) GetAnd() *AndNode {
	if x, ok := x.GetValue().(*QueryNode_And); ok {
		return x.And
	}
	return nil
}

func (x *QueryNode) GetOr() *OrNode {
	if x, ok := x.GetValue().(*QueryNode_Or); ok {
		return x.Or
	}
	return nil
}

type isQueryNode_Value interface {
	isQueryNode_Value()
}

type QueryNode_Pattern struct {
	Pattern *PatternNode `protobuf:"bytes,1,opt,name=pattern,proto3,oneof"`
}

type QueryNode_And struct {
	And *AndNode `protobuf:"bytes,2,opt,name=and,proto3,oneof"`
}

type QueryNode_Or struct {
	Or *OrNode `protobuf:"bytes,3,opt,name=or,proto3,oneof"`
}

func (*QueryNode_Pattern) isQueryNode_Value() {}

func (*QueryNode_And) isQueryNode_Value() {}

func (*QueryNode_Or) isQueryNode_Value() {}

// PatternNode represents a leaf query against a specific pattern
type PatternNode struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// value is the search query. It is a regular expression if IsRegExp
	// is true, otherwise a fixed string.
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	// is_negated if true will invert the matching logic for regexp searches.
	// Structural searches do not support negation.
	IsNegated bool `protobuf:"varint,2,opt,name=is_negated,json=isNegated,proto3" json:"is_negated,omitempty"`
	// is_regexp if true will treat the pattern as a regular expression.
	IsRegexp bool `protobuf:"varint,3,opt,name=is_regexp,json=isRegexp,proto3" json:"is_regexp,omitempty"`
}

func (x *PatternNode) Reset() {
	*x = PatternNode{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PatternNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PatternNode) ProtoMessage() {}

func (x *PatternNode) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PatternNode.ProtoReflect.Descriptor instead.
func (*PatternNode) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{7}
}

func (x *PatternNode) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *PatternNode) GetIsNegated() bool {
	if x != nil {
		return x.IsNegated
	}
	return false
}

func (x *PatternNode) GetIsRegexp() bool {
	if x != nil {
		return x.IsRegexp
	}
	return false
}

type AndNode struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Children []*QueryNode `protobuf:"bytes,1,rep,name=children,proto3" json:"children,omitempty"`
}

func (x *AndNode) Reset() {
	*x = AndNode{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AndNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AndNode) ProtoMessage() {}

func (x *AndNode) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AndNode.ProtoReflect.Descriptor instead.
func (*AndNode) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{8}
}

func (x *AndNode) GetChildren() []*QueryNode {
	if x != nil {
		return x.Children
	}
	return nil
}

type OrNode struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Children []*QueryNode `protobuf:"bytes,1,rep,name=children,proto3" json:"children,omitempty"`
}

func (x *OrNode) Reset() {
	*x = OrNode{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *OrNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OrNode) ProtoMessage() {}

func (x *OrNode) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OrNode.ProtoReflect.Descriptor instead.
func (*OrNode) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{9}
}

func (x *OrNode) GetChildren() []*QueryNode {
	if x != nil {
		return x.Children
	}
	return nil
}

type PatternInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// is_structural if true will treat the pattern as a Comby structural search
	// pattern.
	IsStructural bool `protobuf:"varint,4,opt,name=is_structural,json=isStructural,proto3" json:"is_structural,omitempty"`
	// is_case_sensitive if false will ignore the case of text and pattern
	// when finding matches.
	IsCaseSensitive bool `protobuf:"varint,6,opt,name=is_case_sensitive,json=isCaseSensitive,proto3" json:"is_case_sensitive,omitempty"`
	// exclude_pattern is a pattern that may not match the returned files' paths.
	// eg '**/node_modules'
	ExcludePattern string `protobuf:"bytes,7,opt,name=exclude_pattern,json=excludePattern,proto3" json:"exclude_pattern,omitempty"`
	// include_patterns is a list of patterns that must *all* match the returned
	// files' paths.
	// eg '**/node_modules'
	//
	// The patterns are ANDed together; a file's path must match all patterns
	// for it to be kept. That is also why it is a list (unlike the singular
	// ExcludePattern); it is not possible in general to construct a single
	// glob or Go regexp that represents multiple such patterns ANDed together.
	IncludePatterns []string `protobuf:"bytes,8,rep,name=include_patterns,json=includePatterns,proto3" json:"include_patterns,omitempty"`
	// path_patterns_are_case_sensitive indicates that exclude_pattern and
	// include_patterns are case sensitive.
	PathPatternsAreCaseSensitive bool `protobuf:"varint,9,opt,name=path_patterns_are_case_sensitive,json=pathPatternsAreCaseSensitive,proto3" json:"path_patterns_are_case_sensitive,omitempty"`
	// limit is the cap on the total number of matches returned.
	// A match is either a path match, or a fragment of a line matched by the
	// query.
	Limit int64 `protobuf:"varint,10,opt,name=limit,proto3" json:"limit,omitempty"`
	// pattern_matches_content is whether the pattern should be matched
	// against the content of files.
	PatternMatchesContent bool `protobuf:"varint,11,opt,name=pattern_matches_content,json=patternMatchesContent,proto3" json:"pattern_matches_content,omitempty"`
	// pattern_matches_content is whether a file whose path matches
	// pattern (but whose contents don't) should be considered a match.
	PatternMatchesPath bool `protobuf:"varint,12,opt,name=pattern_matches_path,json=patternMatchesPath,proto3" json:"pattern_matches_path,omitempty"`
	// comby_rule is a rule that constrains matching for structural search.
	// It only applies when IsStructuralPat is true.
	// As a temporary measure, the expression `where "backcompat" == "backcompat"`
	// acts as a flag to activate the old structural search path, which queries
	// zoekt for the file list in the frontend and passes it to searcher.
	CombyRule string `protobuf:"bytes,13,opt,name=comby_rule,json=combyRule,proto3" json:"comby_rule,omitempty"`
	// languages is the list of languages passed via the lang filters (e.g.,
	// "lang:c") and is used for structural search
	Languages []string `protobuf:"bytes,14,rep,name=languages,proto3" json:"languages,omitempty"`
	// select is the value of the the select field in the query. It is not
	// necessary to use it since selection is done after the query completes, but
	// exposing it can enable optimizations.
	Select string `protobuf:"bytes,15,opt,name=select,proto3" json:"select,omitempty"`
	// query defines the query to match files against. It supports regexp
	// patterns optionally combined through boolean operators.
	Query *QueryNode `protobuf:"bytes,16,opt,name=query,proto3" json:"query,omitempty"`
	// include_langs and exclude_langs represent the languages to filter on
	IncludeLangs []string `protobuf:"bytes,17,rep,name=include_langs,json=includeLangs,proto3" json:"include_langs,omitempty"`
	ExcludeLangs []string `protobuf:"bytes,18,rep,name=exclude_langs,json=excludeLangs,proto3" json:"exclude_langs,omitempty"`
}

func (x *PatternInfo) Reset() {
	*x = PatternInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PatternInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PatternInfo) ProtoMessage() {}

func (x *PatternInfo) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PatternInfo.ProtoReflect.Descriptor instead.
func (*PatternInfo) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{10}
}

func (x *PatternInfo) GetIsStructural() bool {
	if x != nil {
		return x.IsStructural
	}
	return false
}

func (x *PatternInfo) GetIsCaseSensitive() bool {
	if x != nil {
		return x.IsCaseSensitive
	}
	return false
}

func (x *PatternInfo) GetExcludePattern() string {
	if x != nil {
		return x.ExcludePattern
	}
	return ""
}

func (x *PatternInfo) GetIncludePatterns() []string {
	if x != nil {
		return x.IncludePatterns
	}
	return nil
}

func (x *PatternInfo) GetPathPatternsAreCaseSensitive() bool {
	if x != nil {
		return x.PathPatternsAreCaseSensitive
	}
	return false
}

func (x *PatternInfo) GetLimit() int64 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *PatternInfo) GetPatternMatchesContent() bool {
	if x != nil {
		return x.PatternMatchesContent
	}
	return false
}

func (x *PatternInfo) GetPatternMatchesPath() bool {
	if x != nil {
		return x.PatternMatchesPath
	}
	return false
}

func (x *PatternInfo) GetCombyRule() string {
	if x != nil {
		return x.CombyRule
	}
	return ""
}

func (x *PatternInfo) GetLanguages() []string {
	if x != nil {
		return x.Languages
	}
	return nil
}

func (x *PatternInfo) GetSelect() string {
	if x != nil {
		return x.Select
	}
	return ""
}

func (x *PatternInfo) GetQuery() *QueryNode {
	if x != nil {
		return x.Query
	}
	return nil
}

func (x *PatternInfo) GetIncludeLangs() []string {
	if x != nil {
		return x.IncludeLangs
	}
	return nil
}

func (x *PatternInfo) GetExcludeLangs() []string {
	if x != nil {
		return x.ExcludeLangs
	}
	return nil
}

type CommitSearchRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// repo is the name of the repo to be searched
	Repo string `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	// revisions is the list of git revision to be searched. They are all passed
	// to the same underlying git command, so the searched commits will be the
	// union of all revisions listed.
	Revisions []*RevisionSpecifier `protobuf:"bytes,2,rep,name=revisions,proto3" json:"revisions,omitempty"`
	// limit is a limit on the number of search results returned. Additional
	// results will be ignored.
	Limit int64 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	// include_diff specifies whether the full diff should be included on the
	// result messages. This can be expensive, so is disabled by default.
	IncludeDiff bool `protobuf:"varint,4,opt,name=include_diff,json=includeDiff,proto3" json:"include_diff,omitempty"`
	// include_modified specifies whether to include the list of modified files
	// in the search results. This can be expensive, so is disabled by default.
	IncludeModifiedFiles bool `protobuf:"varint,5,opt,name=include_modified_files,json=includeModifiedFiles,proto3" json:"include_modified_files,omitempty"`
	// query is a tree of filters to apply to commits being searched.
	Query *CommitSearchQueryNode `protobuf:"bytes,6,opt,name=query,proto3" json:"query,omitempty"`
}

func (x *CommitSearchRequest) Reset() {
	*x = CommitSearchRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CommitSearchRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitSearchRequest) ProtoMessage() {}

func (x *CommitSearchRequest) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitSearchRequest.ProtoReflect.Descriptor instead.
func (*CommitSearchRequest) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{11}
}

func (x *CommitSearchRequest) GetRepo() string {
	if x != nil {
		return x.Repo
	}
	return ""
}

func (x *CommitSearchRequest) GetRevisions() []*RevisionSpecifier {
	if x != nil {
		return x.Revisions
	}
	return nil
}

func (x *CommitSearchRequest) GetLimit() int64 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *CommitSearchRequest) GetIncludeDiff() bool {
	if x != nil {
		return x.IncludeDiff
	}
	return false
}

func (x *CommitSearchRequest) GetIncludeModifiedFiles() bool {
	if x != nil {
		return x.IncludeModifiedFiles
	}
	return false
}

func (x *CommitSearchRequest) GetQuery() *CommitSearchQueryNode {
	if x != nil {
		return x.Query
	}
	return nil
}

type RevisionSpecifier struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// RevSpec is a revision range specifier suitable for passing to git. See
	// the manpage gitrevisions(7).
	RevSpec string `protobuf:"bytes,1,opt,name=rev_spec,json=revSpec,proto3" json:"rev_spec,omitempty"`
}

func (x *RevisionSpecifier) Reset() {
	*x = RevisionSpecifier{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RevisionSpecifier) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RevisionSpecifier) ProtoMessage() {}

func (x *RevisionSpecifier) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RevisionSpecifier.ProtoReflect.Descriptor instead.
func (*RevisionSpecifier) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{12}
}

func (x *RevisionSpecifier) GetRevSpec() string {
	if x != nil {
		return x.RevSpec
	}
	return ""
}

// AuthorMatchesNode is a predicate that matches if the author's name or email
// address matches the regex pattern.
type AuthorMatchesNode struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Expr       string `protobuf:"bytes,1,opt,name=expr,proto3" json:"expr,omitempty"`
	IgnoreCase bool   `protobuf:"varint,2,opt,name=ignore_case,json=ignoreCase,proto3" json:"ignore_case,omitempty"`
}

func (x *AuthorMatchesNode) Reset() {
	*x = AuthorMatchesNode{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AuthorMatchesNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuthorMatchesNode) ProtoMessage() {}

func (x *AuthorMatchesNode) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AuthorMatchesNode.ProtoReflect.Descriptor instead.
func (*AuthorMatchesNode) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{13}
}

func (x *AuthorMatchesNode) GetExpr() string {
	if x != nil {
		return x.Expr
	}
	return ""
}

func (x *AuthorMatchesNode) GetIgnoreCase() bool {
	if x != nil {
		return x.IgnoreCase
	}
	return false
}

// CommitterMatchesNode is a predicate that matches if the author's name or
// email address matches the regex pattern.
type CommitterMatchesNode struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Expr       string `protobuf:"bytes,1,opt,name=expr,proto3" json:"expr,omitempty"`
	IgnoreCase bool   `protobuf:"varint,2,opt,name=ignore_case,json=ignoreCase,proto3" json:"ignore_case,omitempty"`
}

func (x *CommitterMatchesNode) Reset() {
	*x = CommitterMatchesNode{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CommitterMatchesNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitterMatchesNode) ProtoMessage() {}

func (x *CommitterMatchesNode) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitterMatchesNode.ProtoReflect.Descriptor instead.
func (*CommitterMatchesNode) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{14}
}

func (x *CommitterMatchesNode) GetExpr() string {
	if x != nil {
		return x.Expr
	}
	return ""
}

func (x *CommitterMatchesNode) GetIgnoreCase() bool {
	if x != nil {
		return x.IgnoreCase
	}
	return false
}

// CommitBeforeNode is a predicate that matches if the commit is before the
// given date
type CommitBeforeNode struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Timestamp *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (x *CommitBeforeNode) Reset() {
	*x = CommitBeforeNode{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CommitBeforeNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitBeforeNode) ProtoMessage() {}

func (x *CommitBeforeNode) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitBeforeNode.ProtoReflect.Descriptor instead.
func (*CommitBeforeNode) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{15}
}

func (x *CommitBeforeNode) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

// CommitAfterNode is a predicate that matches if the commit is after the given
// date
type CommitAfterNode struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Timestamp *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (x *CommitAfterNode) Reset() {
	*x = CommitAfterNode{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CommitAfterNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitAfterNode) ProtoMessage() {}

func (x *CommitAfterNode) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitAfterNode.ProtoReflect.Descriptor instead.
func (*CommitAfterNode) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{16}
}

func (x *CommitAfterNode) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

// MessageMatchesNode is a predicate that matches if the commit message matches
// the provided regex pattern.
type MessageMatchesNode struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Expr       string `protobuf:"bytes,1,opt,name=expr,proto3" json:"expr,omitempty"`
	IgnoreCase bool   `protobuf:"varint,2,opt,name=ignore_case,json=ignoreCase,proto3" json:"ignore_case,omitempty"`
}

func (x *MessageMatchesNode) Reset() {
	*x = MessageMatchesNode{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MessageMatchesNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MessageMatchesNode) ProtoMessage() {}

func (x *MessageMatchesNode) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MessageMatchesNode.ProtoReflect.Descriptor instead.
func (*MessageMatchesNode) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{17}
}

func (x *MessageMatchesNode) GetExpr() string {
	if x != nil {
		return x.Expr
	}
	return ""
}

func (x *MessageMatchesNode) GetIgnoreCase() bool {
	if x != nil {
		return x.IgnoreCase
	}
	return false
}

// DiffMatchesNode is a a predicate that matches if any of the lines changed by
// the commit match the given regex pattern.
type DiffMatchesNode struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Expr       string `protobuf:"bytes,1,opt,name=expr,proto3" json:"expr,omitempty"`
	IgnoreCase bool   `protobuf:"varint,2,opt,name=ignore_case,json=ignoreCase,proto3" json:"ignore_case,omitempty"`
}

func (x *DiffMatchesNode) Reset() {
	*x = DiffMatchesNode{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DiffMatchesNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DiffMatchesNode) ProtoMessage() {}

func (x *DiffMatchesNode) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DiffMatchesNode.ProtoReflect.Descriptor instead.
func (*DiffMatchesNode) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{18}
}

func (x *DiffMatchesNode) GetExpr() string {
	if x != nil {
		return x.Expr
	}
	return ""
}

func (x *DiffMatchesNode) GetIgnoreCase() bool {
	if x != nil {
		return x.IgnoreCase
	}
	return false
}

// DiffModifiesFileNode is a predicate that matches if the commit modifies any
// files that match the given regex pattern.
type DiffModifiesFileNode struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Expr       string `protobuf:"bytes,1,opt,name=expr,proto3" json:"expr,omitempty"`
	IgnoreCase bool   `protobuf:"varint,2,opt,name=ignore_case,json=ignoreCase,proto3" json:"ignore_case,omitempty"`
}

func (x *DiffModifiesFileNode) Reset() {
	*x = DiffModifiesFileNode{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DiffModifiesFileNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DiffModifiesFileNode) ProtoMessage() {}

func (x *DiffModifiesFileNode) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DiffModifiesFileNode.ProtoReflect.Descriptor instead.
func (*DiffModifiesFileNode) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{19}
}

func (x *DiffModifiesFileNode) GetExpr() string {
	if x != nil {
		return x.Expr
	}
	return ""
}

func (x *DiffModifiesFileNode) GetIgnoreCase() bool {
	if x != nil {
		return x.IgnoreCase
	}
	return false
}

// BooleanNode is a predicate that will either always match or never match
type BooleanNode struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Value bool `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (x *BooleanNode) Reset() {
	*x = BooleanNode{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BooleanNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BooleanNode) ProtoMessage() {}

func (x *BooleanNode) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BooleanNode.ProtoReflect.Descriptor instead.
func (*BooleanNode) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{20}
}

func (x *BooleanNode) GetValue() bool {
	if x != nil {
		return x.Value
	}
	return false
}

type CommitSearchOperatorNode struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Kind     OperatorKind             `protobuf:"varint,1,opt,name=kind,proto3,enum=searcher.v1.OperatorKind" json:"kind,omitempty"`
	Operands []*CommitSearchQueryNode `protobuf:"bytes,2,rep,name=operands,proto3" json:"operands,omitempty"`
}

func (x *CommitSearchOperatorNode) Reset() {
	*x = CommitSearchOperatorNode{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CommitSearchOperatorNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitSearchOperatorNode) ProtoMessage() {}

func (x *CommitSearchOperatorNode) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitSearchOperatorNode.ProtoReflect.Descriptor instead.
func (*CommitSearchOperatorNode) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{21}
}

func (x *CommitSearchOperatorNode) GetKind() OperatorKind {
	if x != nil {
		return x.Kind
	}
	return OperatorKind_OPERATOR_KIND_UNSPECIFIED
}

func (x *CommitSearchOperatorNode) GetOperands() []*CommitSearchQueryNode {
	if x != nil {
		return x.Operands
	}
	return nil
}

type CommitSearchQueryNode struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Value:
	//
	//	*CommitSearchQueryNode_AuthorMatches
	//	*CommitSearchQueryNode_CommitterMatches
	//	*CommitSearchQueryNode_CommitBefore
	//	*CommitSearchQueryNode_CommitAfter
	//	*CommitSearchQueryNode_MessageMatches
	//	*CommitSearchQueryNode_DiffMatches
	//	*CommitSearchQueryNode_DiffModifiesFile
	//	*CommitSearchQueryNode_Boolean
	//	*CommitSearchQueryNode_Operator
	Value isCommitSearchQueryNode_Value `protobuf_oneof:"value"`
}

func (x *CommitSearchQueryNode) Reset() {
	*x = CommitSearchQueryNode{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[22]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CommitSearchQueryNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitSearchQueryNode) ProtoMessage() {}

func (x *CommitSearchQueryNode) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[22]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitSearchQueryNode.ProtoReflect.Descriptor instead.
func (*CommitSearchQueryNode) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{22}
}

func (m *CommitSearchQueryNode) GetValue() isCommitSearchQueryNode_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (x *CommitSearchQueryNode) GetAuthorMatches() *AuthorMatchesNode {
	if x, ok := x.GetValue().(*CommitSearchQueryNode_AuthorMatches); ok {
		return x.AuthorMatches
	}
	return nil
}

func (x *CommitSearchQueryNode) GetCommitterMatches() *CommitterMatchesNode {
	if x, ok := x.GetValue().(*CommitSearchQueryNode_CommitterMatches); ok {
		return x.CommitterMatches
	}
	return nil
}

func (x *CommitSearchQueryNode) GetCommitBefore() *CommitBeforeNode {
	if x, ok := x.GetValue().(*CommitSearchQueryNode_CommitBefore); ok {
		return x.CommitBefore
	}
	return nil
}

func (x *CommitSearchQueryNode) GetCommitAfter() *CommitAfterNode {
	if x, ok := x.GetValue().(*CommitSearchQueryNode_CommitAfter); ok {
		return x.CommitAfter
	}
	return nil
}

func (x *CommitSearchQueryNode) GetMessageMatches() *MessageMatchesNode {
	if x, ok := x.GetValue().(*CommitSearchQueryNode_MessageMatches); ok {
		return x.MessageMatches
	}
	return nil
}

func (x *CommitSearchQueryNode) GetDiffMatches() *DiffMatchesNode {
	if x, ok := x.GetValue().(*CommitSearchQueryNode_DiffMatches); ok {
		return x.DiffMatches
	}
	return nil
}

func (x *CommitSearchQueryNode) GetDiffModifiesFile() *DiffModifiesFileNode {
	if x, ok := x.GetValue().(*CommitSearchQueryNode_DiffModifiesFile); ok {
		return x.DiffModifiesFile
	}
	return nil
}

func (x *CommitSearchQueryNode) GetBoolean() *BooleanNode {
	if x, ok := x.GetValue().(*CommitSearchQueryNode_Boolean); ok {
		return x.Boolean
	}
	return nil
}

func (x *CommitSearchQueryNode) GetOperator() *CommitSearchOperatorNode {
	if x, ok := x.GetValue().(*CommitSearchQueryNode_Operator); ok {
		return x.Operator
	}
	return nil
}

type isCommitSearchQueryNode_Value interface {
	isCommitSearchQueryNode_Value()
}

type CommitSearchQueryNode_AuthorMatches struct {
	AuthorMatches *AuthorMatchesNode `protobuf:"bytes,1,opt,name=author_matches,json=authorMatches,proto3,oneof"`
}

type CommitSearchQueryNode_CommitterMatches struct {
	CommitterMatches *CommitterMatchesNode `protobuf:"bytes,2,opt,name=committer_matches,json=committerMatches,proto3,oneof"`
}

type CommitSearchQueryNode_CommitBefore struct {
	CommitBefore *CommitBeforeNode `protobuf:"bytes,3,opt,name=commit_before,json=commitBefore,proto3,oneof"`
}

type CommitSearchQueryNode_CommitAfter struct {
	CommitAfter *CommitAfterNode `protobuf:"bytes,4,opt,name=commit_after,json=commitAfter,proto3,oneof"`
}

type CommitSearchQueryNode_MessageMatches struct {
	MessageMatches *MessageMatchesNode `protobuf:"bytes,5,opt,name=message_matches,json=messageMatches,proto3,oneof"`
}

type CommitSearchQueryNode_DiffMatches struct {
	DiffMatches *DiffMatchesNode `protobuf:"bytes,6,opt,name=diff_matches,json=diffMatches,proto3,oneof"`
}

type CommitSearchQueryNode_DiffModifiesFile struct {
	DiffModifiesFile *DiffModifiesFileNode `protobuf:"bytes,7,opt,name=diff_modifies_file,json=diffModifiesFile,proto3,oneof"`
}

type CommitSearchQueryNode_Boolean struct {
	Boolean *BooleanNode `protobuf:"bytes,8,opt,name=boolean,proto3,oneof"`
}

type CommitSearchQueryNode_Operator struct {
	Operator *CommitSearchOperatorNode `protobuf:"bytes,9,opt,name=operator,proto3,oneof"`
}

func (*CommitSearchQueryNode_AuthorMatches) isCommitSearchQueryNode_Value() {}

func (*CommitSearchQueryNode_CommitterMatches) isCommitSearchQueryNode_Value() {}

func (*CommitSearchQueryNode_CommitBefore) isCommitSearchQueryNode_Value() {}

func (*CommitSearchQueryNode_CommitAfter) isCommitSearchQueryNode_Value() {}

func (*CommitSearchQueryNode_MessageMatches) isCommitSearchQueryNode_Value() {}

func (*CommitSearchQueryNode_DiffMatches) isCommitSearchQueryNode_Value() {}

func (*CommitSearchQueryNode_DiffModifiesFile) isCommitSearchQueryNode_Value() {}

func (*CommitSearchQueryNode_Boolean) isCommitSearchQueryNode_Value() {}

func (*CommitSearchQueryNode_Operator) isCommitSearchQueryNode_Value() {}

type CommitSearchResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Message:
	//
	//	*CommitSearchResponse_Match
	//	*CommitSearchResponse_LimitHit
	Message isCommitSearchResponse_Message `protobuf_oneof:"message"`
}

func (x *CommitSearchResponse) Reset() {
	*x = CommitSearchResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[23]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CommitSearchResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitSearchResponse) ProtoMessage() {}

func (x *CommitSearchResponse) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[23]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitSearchResponse.ProtoReflect.Descriptor instead.
func (*CommitSearchResponse) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{23}
}

func (m *CommitSearchResponse) GetMessage() isCommitSearchResponse_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (x *CommitSearchResponse) GetMatch() *CommitMatch {
	if x, ok := x.GetMessage().(*CommitSearchResponse_Match); ok {
		return x.Match
	}
	return nil
}

func (x *CommitSearchResponse) GetLimitHit() bool {
	if x, ok := x.GetMessage().(*CommitSearchResponse_LimitHit); ok {
		return x.LimitHit
	}
	return false
}

type isCommitSearchResponse_Message interface {
	isCommitSearchResponse_Message()
}

type CommitSearchResponse_Match struct {
	Match *CommitMatch `protobuf:"bytes,1,opt,name=match,proto3,oneof"`
}

type CommitSearchResponse_LimitHit struct {
	LimitHit bool `protobuf:"varint,2,opt,name=limit_hit,json=limitHit,proto3,oneof"`
}

func (*CommitSearchResponse_Match) isCommitSearchResponse_Message() {}

func (*CommitSearchResponse_LimitHit) isCommitSearchResponse_Message() {}

type CommitMatch struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// oid is the 40-character, hex-encoded commit hash
	Oid       string                 `protobuf:"bytes,1,opt,name=oid,proto3" json:"oid,omitempty"`
	Author    *CommitMatch_Signature `protobuf:"bytes,2,opt,name=author,proto3" json:"author,omitempty"`
	Committer *CommitMatch_Signature `protobuf:"bytes,3,opt,name=committer,proto3" json:"committer,omitempty"`
	// parents is the list of commit hashes for this commit's parents
	Parents    []string `protobuf:"bytes,4,rep,name=parents,proto3" json:"parents,omitempty"`
	Refs       []string `protobuf:"bytes,5,rep,name=refs,proto3" json:"refs,omitempty"`
	SourceRefs []string `protobuf:"bytes,6,rep,name=source_refs,json=sourceRefs,proto3" json:"source_refs,omitempty"`
	// message is the commits message and a list of ranges that match
	// the search query.
	Message *CommitMatch_MatchedString `protobuf:"bytes,7,opt,name=message,proto3" json:"message,omitempty"`
	// diff is the diff between this commit and its first parent.
	// May be unset if `include_diff` was not specified in the request.
	Diff *CommitMatch_MatchedString `protobuf:"bytes,8,opt,name=diff,proto3" json:"diff,omitempty"`
	// modified_files is the list of files modified by this commit compared
	// to its first parent. May be unset if `include_modified_files` is not
	// specified in the request.
	ModifiedFiles []string `protobuf:"bytes,9,rep,name=modified_files,json=modifiedFiles,proto3" json:"modified_files,omitempty"`
}

func (x *CommitMatch) Reset() {
	*x = CommitMatch{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[24]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CommitMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitMatch) ProtoMessage() {}

func (x *CommitMatch) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[24]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitMatch.ProtoReflect.Descriptor instead.
func (*CommitMatch) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{24}
}

func (x *CommitMatch) GetOid() string {
	if x != nil {
		return x.Oid
	}
	return ""
}

func (x *CommitMatch) GetAuthor() *CommitMatch_Signature {
	if x != nil {
		return x.Author
	}
	return nil
}

func (x *CommitMatch) GetCommitter() *CommitMatch_Signature {
	if x != nil {
		return x.Committer
	}
	return nil
}

func (x *CommitMatch) GetParents() []string {
	if x != nil {
		return x.Parents
	}
	return nil
}

func (x *CommitMatch) GetRefs() []string {
	if x != nil {
		return x.Refs
	}
	return nil
}

func (x *CommitMatch) GetSourceRefs() []string {
	if x != nil {
		return x.SourceRefs
	}
	return nil
}

func (x *CommitMatch) GetMessage() *CommitMatch_MatchedString {
	if x != nil {
		return x.Message
	}
	return nil
}

func (x *CommitMatch) GetDiff() *CommitMatch_MatchedString {
	if x != nil {
		return x.Diff
	}
	return nil
}

func (x *CommitMatch) GetModifiedFiles() []string {
	if x != nil {
		return x.ModifiedFiles
	}
	return nil
}

// Done is the final SearchResponse message sent in the stream
// of responses to Search.
type SearchResponse_Done struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	LimitHit bool `protobuf:"varint,1,opt,name=limit_hit,json=limitHit,proto3" json:"limit_hit,omitempty"`
}

func (x *SearchResponse_Done) Reset() {
	*x = SearchResponse_Done{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[25]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SearchResponse_Done) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchResponse_Done) ProtoMessage() {}

func (x *SearchResponse_Done) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[25]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchResponse_Done.ProtoReflect.Descriptor instead.
func (*SearchResponse_Done) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{1, 0}
}

func (x *SearchResponse_Done) GetLimitHit() bool {
	if x != nil {
		return x.LimitHit
	}
	return false
}

type CommitMatch_Signature struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Name  string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Email string                 `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
	Date  *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=date,proto3" json:"date,omitempty"`
}

func (x *CommitMatch_Signature) Reset() {
	*x = CommitMatch_Signature{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[26]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CommitMatch_Signature) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitMatch_Signature) ProtoMessage() {}

func (x *CommitMatch_Signature) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[26]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitMatch_Signature.ProtoReflect.Descriptor instead.
func (*CommitMatch_Signature) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{24, 0}
}

func (x *CommitMatch_Signature) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CommitMatch_Signature) GetEmail() string {
	if x != nil {
		return x.Email
	}
	return ""
}

func (x *CommitMatch_Signature) GetDate() *timestamppb.Timestamp {
	if x != nil {
		return x.Date
	}
	return nil
}

type CommitMatch_MatchedString struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Content string               `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	Ranges  []*CommitMatch_Range `protobuf:"bytes,2,rep,name=ranges,proto3" json:"ranges,omitempty"`
}

func (x *CommitMatch_MatchedString) Reset() {
	*x = CommitMatch_MatchedString{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[27]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CommitMatch_MatchedString) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitMatch_MatchedString) ProtoMessage() {}

func (x *CommitMatch_MatchedString) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[27]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitMatch_MatchedString.ProtoReflect.Descriptor instead.
func (*CommitMatch_MatchedString) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{24, 1}
}

func (x *CommitMatch_MatchedString) GetContent() string {
	if x != nil {
		return x.Content
	}
	return ""
}

func (x *CommitMatch_MatchedString) GetRanges() []*CommitMatch_Range {
	if x != nil {
		return x.Ranges
	}
	return nil
}

// TODO move this into a shared package
type CommitMatch_Range struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Start *CommitMatch_Location `protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"`
	End   *CommitMatch_Location `protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (x *CommitMatch_Range) Reset() {
	*x = CommitMatch_Range{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[28]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CommitMatch_Range) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitMatch_Range) ProtoMessage() {}

func (x *CommitMatch_Range) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[28]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitMatch_Range.ProtoReflect.Descriptor instead.
func (*CommitMatch_Range) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{24, 2}
}

func (x *CommitMatch_Range) GetStart() *CommitMatch_Location {
	if x != nil {
		return x.Start
	}
	return nil
}

func (x *CommitMatch_Range) GetEnd() *CommitMatch_Location {
	if x != nil {
		return x.End
	}
	return nil
}

type CommitMatch_Location struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Offset uint32 `protobuf:"varint,1,opt,name=offset,proto3" json:"offset,omitempty"`
	Line   uint32 `protobuf:"varint,2,opt,name=line,proto3" json:"line,omitempty"`
	Column uint32 `protobuf:"varint,3,opt,name=column,proto3" json:"column,omitempty"`
}

func (x *CommitMatch_Location) Reset() {
	*x = CommitMatch_Location{}
	if protoimpl.UnsafeEnabled {
		mi := &file_searcher_proto_msgTypes[29]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CommitMatch_Location) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitMatch_Location) ProtoMessage() {}

func (x *CommitMatch_Location) ProtoReflect() protoreflect.Message {
	mi := &file_searcher_proto_msgTypes[29]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitMatch_Location.ProtoReflect.Descriptor instead.
func (*CommitMatch_Location) Descriptor() ([]byte, []int) {
	return file_searcher_proto_rawDescGZIP(), []int{24, 3}
}

func (x *CommitMatch_Location) GetOffset() uint32 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *CommitMatch_Location) GetLine() uint32 {
	if x != nil {
		return x.Line
	}
	return 0
}

func (x *CommitMatch_Location) GetColumn() uint32 {
	if x != nil {
		return x.Column
	}
	return 0
}

var File_searcher_proto protoreflect.FileDescriptor

var file_searcher_proto_rawDesc = []byte{
	0x0a, 0x0e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x12, 0x0b, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x1a, 0x1e, 0x67,
	0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64,
	0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1f, 0x67,
	0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74,
	0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xce,
	0x02, 0x0a, 0x0d, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x12, 0x12, 0x0a, 0x04, 0x72, 0x65, 0x70, 0x6f, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
	0x72, 0x65, 0x70, 0x6f, 0x12, 0x17, 0x0a, 0x07, 0x72, 0x65, 0x70, 0x6f, 0x5f, 0x69, 0x64, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x72, 0x65, 0x70, 0x6f, 0x49, 0x64, 0x12, 0x1d, 0x0a,
	0x0a, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x5f, 0x6f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x09, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x4f, 0x69, 0x64, 0x12, 0x18, 0x0a, 0x07,
	0x69, 0x6e, 0x64, 0x65, 0x78, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x69,
	0x6e, 0x64, 0x65, 0x78, 0x65, 0x64, 0x12, 0x3b, 0x0a, 0x0c, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72,
	0x6e, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x73,
	0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x61, 0x74, 0x74, 0x65,
	0x72, 0x6e, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x0b, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x49,
	0x6e, 0x66, 0x6f, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x03, 0x75, 0x72, 0x6c, 0x12, 0x16, 0x0a, 0x06, 0x62, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x18,
	0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x62, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x12, 0x3e, 0x0a,
	0x0d, 0x66, 0x65, 0x74, 0x63, 0x68, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x08,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52,
	0x0c, 0x66, 0x65, 0x74, 0x63, 0x68, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x12, 0x2a, 0x0a,
	0x11, 0x6e, 0x75, 0x6d, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x5f, 0x6c, 0x69, 0x6e,
	0x65, 0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0f, 0x6e, 0x75, 0x6d, 0x43, 0x6f, 0x6e,
	0x74, 0x65, 0x78, 0x74, 0x4c, 0x69, 0x6e, 0x65, 0x73, 0x4a, 0x04, 0x08, 0x09, 0x10, 0x0a, 0x22,
	0xc6, 0x01, 0x0a, 0x0e, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x12, 0x37, 0x0a, 0x0a, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65,
	0x72, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x69, 0x6c, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x48, 0x00,
	0x52, 0x09, 0x66, 0x69, 0x6c, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x45, 0x0a, 0x0c, 0x64,
	0x6f, 0x6e, 0x65, 0x5f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x20, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e,
	0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x44,
	0x6f, 0x6e, 0x65, 0x48, 0x00, 0x52, 0x0b, 0x64, 0x6f, 0x6e, 0x65, 0x4d, 0x65, 0x73, 0x73, 0x61,
	0x67, 0x65, 0x1a, 0x29, 0x0a, 0x04, 0x44, 0x6f, 0x6e, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x6c, 0x69,
	0x6d, 0x69, 0x74, 0x5f, 0x68, 0x69, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x6c,
	0x69, 0x6d, 0x69, 0x74, 0x48, 0x69, 0x74, 0x4a, 0x04, 0x08, 0x02, 0x10, 0x03, 0x42, 0x09, 0x0a,
	0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x96, 0x01, 0x0a, 0x09, 0x46, 0x69, 0x6c,
	0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x12, 0x0a, 0x04, 0x70, 0x61, 0x74, 0x68, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0c, 0x52, 0x04, 0x70, 0x61, 0x74, 0x68, 0x12, 0x3c, 0x0a, 0x0d, 0x63, 0x68,
	0x75, 0x6e, 0x6b, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28,
	0x0b, 0x32, 0x17, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e,
	0x43, 0x68, 0x75, 0x6e, 0x6b, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x52, 0x0c, 0x63, 0x68, 0x75, 0x6e,
	0x6b, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x12, 0x1b, 0x0a, 0x09, 0x6c, 0x69, 0x6d, 0x69,
	0x74, 0x5f, 0x68, 0x69, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x6c, 0x69, 0x6d,
	0x69, 0x74, 0x48, 0x69, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
	0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x08, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67,
	0x65, 0x22, 0x8e, 0x01, 0x0a, 0x0a, 0x43, 0x68, 0x75, 0x6e, 0x6b, 0x4d, 0x61, 0x74, 0x63, 0x68,
	0x12, 0x18, 0x0a, 0x07, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0c, 0x52, 0x07, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x12, 0x3a, 0x0a, 0x0d, 0x63, 0x6f,
	0x6e, 0x74, 0x65, 0x6e, 0x74, 0x5f, 0x73, 0x74, 0x61, 0x72, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x15, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e,
	0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0c, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e,
	0x74, 0x53, 0x74, 0x61, 0x72, 0x74, 0x12, 0x2a, 0x0a, 0x06, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x73,
	0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65,
	0x72, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x06, 0x72, 0x61, 0x6e, 0x67,
	0x65, 0x73, 0x22, 0x5d, 0x0a, 0x05, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x2b, 0x0a, 0x05, 0x73,
	0x74, 0x61, 0x72, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x73, 0x65, 0x61,
	0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x52, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x12, 0x27, 0x0a, 0x03, 0x65, 0x6e, 0x64, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72,
	0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x03, 0x65, 0x6e,
	0x64, 0x22, 0x4e, 0x0a, 0x08, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x16, 0x0a,
	0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x6f,
	0x66, 0x66, 0x73, 0x65, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x6c, 0x69, 0x6e, 0x65, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x05, 0x52, 0x04, 0x6c, 0x69, 0x6e, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x63, 0x6f, 0x6c,
	0x75, 0x6d, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x06, 0x63, 0x6f, 0x6c, 0x75, 0x6d,
	0x6e, 0x22, 0x9b, 0x01, 0x0a, 0x09, 0x51, 0x75, 0x65, 0x72, 0x79, 0x4e, 0x6f, 0x64, 0x65, 0x12,
	0x34, 0x0a, 0x07, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x18, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x50,
	0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x4e, 0x6f, 0x64, 0x65, 0x48, 0x00, 0x52, 0x07, 0x70, 0x61,
	0x74, 0x74, 0x65, 0x72, 0x6e, 0x12, 0x28, 0x0a, 0x03, 0x61, 0x6e, 0x64, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x14, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31,
	0x2e, 0x41, 0x6e, 0x64, 0x4e, 0x6f, 0x64, 0x65, 0x48, 0x00, 0x52, 0x03, 0x61, 0x6e, 0x64, 0x12,
	0x25, 0x0a, 0x02, 0x6f, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x73, 0x65,
	0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x72, 0x4e, 0x6f, 0x64, 0x65,
	0x48, 0x00, 0x52, 0x02, 0x6f, 0x72, 0x42, 0x07, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x22,
	0x5f, 0x0a, 0x0b, 0x50, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x4e, 0x6f, 0x64, 0x65, 0x12, 0x14,
	0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76,
	0x61, 0x6c, 0x75, 0x65, 0x12, 0x1d, 0x0a, 0x0a, 0x69, 0x73, 0x5f, 0x6e, 0x65, 0x67, 0x61, 0x74,
	0x65, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x69, 0x73, 0x4e, 0x65, 0x67, 0x61,
	0x74, 0x65, 0x64, 0x12, 0x1b, 0x0a, 0x09, 0x69, 0x73, 0x5f, 0x72, 0x65, 0x67, 0x65, 0x78, 0x70,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x69, 0x73, 0x52, 0x65, 0x67, 0x65, 0x78, 0x70,
	0x22, 0x3d, 0x0a, 0x07, 0x41, 0x6e, 0x64, 0x4e, 0x6f, 0x64, 0x65, 0x12, 0x32, 0x0a, 0x08, 0x63,
	0x68, 0x69, 0x6c, 0x64, 0x72, 0x65, 0x6e, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e,
	0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x51, 0x75, 0x65, 0x72,
	0x79, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x08, 0x63, 0x68, 0x69, 0x6c, 0x64, 0x72, 0x65, 0x6e, 0x22,
	0x3c, 0x0a, 0x06, 0x4f, 0x72, 0x4e, 0x6f, 0x64, 0x65, 0x12, 0x32, 0x0a, 0x08, 0x63, 0x68, 0x69,
	0x6c, 0x64, 0x72, 0x65, 0x6e, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x73, 0x65,
	0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x51, 0x75, 0x65, 0x72, 0x79, 0x4e,
	0x6f, 0x64, 0x65, 0x52, 0x08, 0x63, 0x68, 0x69, 0x6c, 0x64, 0x72, 0x65, 0x6e, 0x22, 0xdf, 0x04,
	0x0a, 0x0b, 0x50, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x23, 0x0a,
	0x0d, 0x69, 0x73, 0x5f, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x61, 0x6c, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x0c, 0x69, 0x73, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72,
	0x61, 0x6c, 0x12, 0x2a, 0x0a, 0x11, 0x69, 0x73, 0x5f, 0x63, 0x61, 0x73, 0x65, 0x5f, 0x73, 0x65,
	0x6e, 0x73, 0x69, 0x74, 0x69, 0x76, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0f, 0x69,
	0x73, 0x43, 0x61, 0x73, 0x65, 0x53, 0x65, 0x6e, 0x73, 0x69, 0x74, 0x69, 0x76, 0x65, 0x12, 0x27,
	0x0a, 0x0f, 0x65, 0x78, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x5f, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72,
	0x6e, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x65, 0x78, 0x63, 0x6c, 0x75, 0x64, 0x65,
	0x50, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x12, 0x29, 0x0a, 0x10, 0x69, 0x6e, 0x63, 0x6c, 0x75,
	0x64, 0x65, 0x5f, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x73, 0x18, 0x08, 0x20, 0x03, 0x28,
	0x09, 0x52, 0x0f, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x50, 0x61, 0x74, 0x74, 0x65, 0x72,
	0x6e, 0x73, 0x12, 0x46, 0x0a, 0x20, 0x70, 0x61, 0x74, 0x68, 0x5f, 0x70, 0x61, 0x74, 0x74, 0x65,
	0x72, 0x6e, 0x73, 0x5f, 0x61, 0x72, 0x65, 0x5f, 0x63, 0x61, 0x73, 0x65, 0x5f, 0x73, 0x65, 0x6e,
	0x73, 0x69, 0x74, 0x69, 0x76, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x08, 0x52, 0x1c, 0x70, 0x61,
	0x74, 0x68, 0x50, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x73, 0x41, 0x72, 0x65, 0x43, 0x61, 0x73,
	0x65, 0x53, 0x65, 0x6e, 0x73, 0x69, 0x74, 0x69, 0x76, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x69,
	0x6d, 0x69, 0x74, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x03, 0x52, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74,
	0x12, 0x36, 0x0a, 0x17, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x5f, 0x6d, 0x61, 0x74, 0x63,
	0x68, 0x65, 0x73, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x18, 0x0b, 0x20, 0x01, 0x28,
	0x08, 0x52, 0x15, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65,
	0x73, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x12, 0x30, 0x0a, 0x14, 0x70, 0x61, 0x74, 0x74,
	0x65, 0x72, 0x6e, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x5f, 0x70, 0x61, 0x74, 0x68,
	0x18, 0x0c, 0x20, 0x01, 0x28, 0x08, 0x52, 0x12, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x4d,
	0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x50, 0x61, 0x74, 0x68, 0x12, 0x1d, 0x0a, 0x0a, 0x63, 0x6f,
	0x6d, 0x62, 0x79, 0x5f, 0x72, 0x75, 0x6c, 0x65, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09,
	0x63, 0x6f, 0x6d, 0x62, 0x79, 0x52, 0x75, 0x6c, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x73, 0x18, 0x0e, 0x20, 0x03, 0x28, 0x09, 0x52, 0x09, 0x6c, 0x61,
	0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x65, 0x6c, 0x65, 0x63,
	0x74, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x12,
	0x2c, 0x0a, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x18, 0x10, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16,
	0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x51, 0x75, 0x65,
	0x72, 0x79, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x12, 0x23, 0x0a,
	0x0d, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x5f, 0x6c, 0x61, 0x6e, 0x67, 0x73, 0x18, 0x11,
	0x20, 0x03, 0x28, 0x09, 0x52, 0x0c, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x4c, 0x61, 0x6e,
	0x67, 0x73, 0x12, 0x23, 0x0a, 0x0d, 0x65, 0x78, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x5f, 0x6c, 0x61,
	0x6e, 0x67, 0x73, 0x18, 0x12, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0c, 0x65, 0x78, 0x63, 0x6c, 0x75,
	0x64, 0x65, 0x4c, 0x61, 0x6e, 0x67, 0x73, 0x4a, 0x04, 0x08, 0x01, 0x10, 0x02, 0x4a, 0x04, 0x08,
	0x02, 0x10, 0x03, 0x4a, 0x04, 0x08, 0x03, 0x10, 0x04, 0x4a, 0x04, 0x08, 0x05, 0x10, 0x06, 0x22,
	0x90, 0x02, 0x0a, 0x13, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x72, 0x65, 0x70, 0x6f, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x72, 0x65, 0x70, 0x6f, 0x12, 0x3c, 0x0a, 0x09, 0x72,
	0x65, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1e,
	0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x76,
	0x69, 0x73, 0x69, 0x6f, 0x6e, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x72, 0x52, 0x09,
	0x72, 0x65, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x69, 0x6d,
	0x69, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x05, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x12,
	0x21, 0x0a, 0x0c, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x5f, 0x64, 0x69, 0x66, 0x66, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x44, 0x69,
	0x66, 0x66, 0x12, 0x34, 0x0a, 0x16, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x5f, 0x6d, 0x6f,
	0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x73, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x14, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x4d, 0x6f, 0x64, 0x69, 0x66,
	0x69, 0x65, 0x64, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x12, 0x38, 0x0a, 0x05, 0x71, 0x75, 0x65, 0x72,
	0x79, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68,
	0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x53, 0x65, 0x61, 0x72,
	0x63, 0x68, 0x51, 0x75, 0x65, 0x72, 0x79, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x05, 0x71, 0x75, 0x65,
	0x72, 0x79, 0x22, 0x3a, 0x0a, 0x11, 0x52, 0x65, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x53, 0x70,
	0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x72, 0x12, 0x19, 0x0a, 0x08, 0x72, 0x65, 0x76, 0x5f, 0x73,
	0x70, 0x65, 0x63, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x72, 0x65, 0x76, 0x53, 0x70,
	0x65, 0x63, 0x4a, 0x04, 0x08, 0x02, 0x10, 0x03, 0x4a, 0x04, 0x08, 0x03, 0x10, 0x04, 0x22, 0x48,
	0x0a, 0x11, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x4e,
	0x6f, 0x64, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x65, 0x78, 0x70, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x04, 0x65, 0x78, 0x70, 0x72, 0x12, 0x1f, 0x0a, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72,
	0x65, 0x5f, 0x63, 0x61, 0x73, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x69, 0x67,
	0x6e, 0x6f, 0x72, 0x65, 0x43, 0x61, 0x73, 0x65, 0x22, 0x4b, 0x0a, 0x14, 0x43, 0x6f, 0x6d, 0x6d,
	0x69, 0x74, 0x74, 0x65, 0x72, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x4e, 0x6f, 0x64, 0x65,
	0x12, 0x12, 0x0a, 0x04, 0x65, 0x78, 0x70, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
	0x65, 0x78, 0x70, 0x72, 0x12, 0x1f, 0x0a, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x63,
	0x61, 0x73, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x69, 0x67, 0x6e, 0x6f, 0x72,
	0x65, 0x43, 0x61, 0x73, 0x65, 0x22, 0x4c, 0x0a, 0x10, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x42,
	0x65, 0x66, 0x6f, 0x72, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x12, 0x38, 0x0a, 0x09, 0x74, 0x69, 0x6d,
	0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67,
	0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54,
	0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74,
	0x61, 0x6d, 0x70, 0x22, 0x4b, 0x0a, 0x0f, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x41, 0x66, 0x74,
	0x65, 0x72, 0x4e, 0x6f, 0x64, 0x65, 0x12, 0x38, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74,
	0x61, 0x6d, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67,
	0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65,
	0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
	0x22, 0x49, 0x0a, 0x12, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68,
	0x65, 0x73, 0x4e, 0x6f, 0x64, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x65, 0x78, 0x70, 0x72, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x65, 0x78, 0x70, 0x72, 0x12, 0x1f, 0x0a, 0x0b, 0x69, 0x67,
	0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x63, 0x61, 0x73, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x0a, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x43, 0x61, 0x73, 0x65, 0x22, 0x46, 0x0a, 0x0f, 0x44,
	0x69, 0x66, 0x66, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x4e, 0x6f, 0x64, 0x65, 0x12, 0x12,
	0x0a, 0x04, 0x65, 0x78, 0x70, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x65, 0x78,
	0x70, 0x72, 0x12, 0x1f, 0x0a, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x63, 0x61, 0x73,
	0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x43,
	0x61, 0x73, 0x65, 0x22, 0x4b, 0x0a, 0x14, 0x44, 0x69, 0x66, 0x66, 0x4d, 0x6f, 0x64, 0x69, 0x66,
	0x69, 0x65, 0x73, 0x46, 0x69, 0x6c, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x65,
	0x78, 0x70, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x65, 0x78, 0x70, 0x72, 0x12,
	0x1f, 0x0a, 0x0b, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x5f, 0x63, 0x61, 0x73, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x43, 0x61, 0x73, 0x65,
	0x22, 0x23, 0x0a, 0x0b, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x4e, 0x6f, 0x64, 0x65, 0x12,
	0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x05,
	0x76, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x89, 0x01, 0x0a, 0x18, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74,
	0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x4e, 0x6f,
	0x64, 0x65, 0x12, 0x2d, 0x0a, 0x04, 0x6b, 0x69, 0x6e, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e,
	0x32, 0x19, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x4f,
	0x70, 0x65, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x4b, 0x69, 0x6e, 0x64, 0x52, 0x04, 0x6b, 0x69, 0x6e,
	0x64, 0x12, 0x3e, 0x0a, 0x08, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x6e, 0x64, 0x73, 0x18, 0x02, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76,
	0x31, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x51, 0x75,
	0x65, 0x72, 0x79, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x08, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x6e, 0x64,
	0x73, 0x22, 0xa1, 0x05, 0x0a, 0x15, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x53, 0x65, 0x61, 0x72,
	0x63, 0x68, 0x51, 0x75, 0x65, 0x72, 0x79, 0x4e, 0x6f, 0x64, 0x65, 0x12, 0x47, 0x0a, 0x0e, 0x61,
	0x75, 0x74, 0x68, 0x6f, 0x72, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76,
	0x31, 0x2e, 0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x4e,
	0x6f, 0x64, 0x65, 0x48, 0x00, 0x52, 0x0d, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x4d, 0x61, 0x74,
	0x63, 0x68, 0x65, 0x73, 0x12, 0x50, 0x0a, 0x11, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x74, 0x65,
	0x72, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x21, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f,
	0x6d, 0x6d, 0x69, 0x74, 0x74, 0x65, 0x72, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x4e, 0x6f,
	0x64, 0x65, 0x48, 0x00, 0x52, 0x10, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x74, 0x65, 0x72, 0x4d,
	0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x12, 0x44, 0x0a, 0x0d, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74,
	0x5f, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e,
	0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6d, 0x6d,
	0x69, 0x74, 0x42, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x48, 0x00, 0x52, 0x0c,
	0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x42, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x12, 0x41, 0x0a, 0x0c,
	0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x5f, 0x61, 0x66, 0x74, 0x65, 0x72, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31,
	0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x41, 0x66, 0x74, 0x65, 0x72, 0x4e, 0x6f, 0x64, 0x65,
	0x48, 0x00, 0x52, 0x0b, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x41, 0x66, 0x74, 0x65, 0x72, 0x12,
	0x4a, 0x0a, 0x0f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68,
	0x65, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63,
	0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x4d, 0x61,
	0x74, 0x63, 0x68, 0x65, 0x73, 0x4e, 0x6f, 0x64, 0x65, 0x48, 0x00, 0x52, 0x0e, 0x6d, 0x65, 0x73,
	0x73, 0x61, 0x67, 0x65, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x12, 0x41, 0x0a, 0x0c, 0x64,
	0x69, 0x66, 0x66, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x1c, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e,
	0x44, 0x69, 0x66, 0x66, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x4e, 0x6f, 0x64, 0x65, 0x48,
	0x00, 0x52, 0x0b, 0x64, 0x69, 0x66, 0x66, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x12, 0x51,
	0x0a, 0x12, 0x64, 0x69, 0x66, 0x66, 0x5f, 0x6d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x65, 0x73, 0x5f,
	0x66, 0x69, 0x6c, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x73, 0x65, 0x61,
	0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x69, 0x66, 0x66, 0x4d, 0x6f, 0x64,
	0x69, 0x66, 0x69, 0x65, 0x73, 0x46, 0x69, 0x6c, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x48, 0x00, 0x52,
	0x10, 0x64, 0x69, 0x66, 0x66, 0x4d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x65, 0x73, 0x46, 0x69, 0x6c,
	0x65, 0x12, 0x34, 0x0a, 0x07, 0x62, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x18, 0x08, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x18, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31,
	0x2e, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x4e, 0x6f, 0x64, 0x65, 0x48, 0x00, 0x52, 0x07,
	0x62, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x12, 0x43, 0x0a, 0x08, 0x6f, 0x70, 0x65, 0x72, 0x61,
	0x74, 0x6f, 0x72, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x73, 0x65, 0x61, 0x72,
	0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x53, 0x65,
	0x61, 0x72, 0x63, 0x68, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x4e, 0x6f, 0x64, 0x65,
	0x48, 0x00, 0x52, 0x08, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x42, 0x07, 0x0a, 0x05,
	0x76, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x72, 0x0a, 0x14, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x53,
	0x65, 0x61, 0x72, 0x63, 0x68, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x30, 0x0a,
	0x05, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x73,
	0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x69,
	0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x48, 0x00, 0x52, 0x05, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x12,
	0x1d, 0x0a, 0x09, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x5f, 0x68, 0x69, 0x74, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x08, 0x48, 0x00, 0x52, 0x08, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x48, 0x69, 0x74, 0x42, 0x09,
	0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0xa2, 0x06, 0x0a, 0x0b, 0x43, 0x6f,
	0x6d, 0x6d, 0x69, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x10, 0x0a, 0x03, 0x6f, 0x69, 0x64,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6f, 0x69, 0x64, 0x12, 0x3a, 0x0a, 0x06, 0x61,
	0x75, 0x74, 0x68, 0x6f, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x73, 0x65,
	0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74,
	0x4d, 0x61, 0x74, 0x63, 0x68, 0x2e, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x52,
	0x06, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x12, 0x40, 0x0a, 0x09, 0x63, 0x6f, 0x6d, 0x6d, 0x69,
	0x74, 0x74, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x73, 0x65, 0x61,
	0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x4d,
	0x61, 0x74, 0x63, 0x68, 0x2e, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x52, 0x09,
	0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x74, 0x65, 0x72, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x61, 0x72,
	0x65, 0x6e, 0x74, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x70, 0x61, 0x72, 0x65,
	0x6e, 0x74, 0x73, 0x12, 0x12, 0x0a, 0x04, 0x72, 0x65, 0x66, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28,
	0x09, 0x52, 0x04, 0x72, 0x65, 0x66, 0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x73, 0x6f, 0x75, 0x72, 0x63,
	0x65, 0x5f, 0x72, 0x65, 0x66, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0a, 0x73, 0x6f,
	0x75, 0x72, 0x63, 0x65, 0x52, 0x65, 0x66, 0x73, 0x12, 0x40, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73,
	0x61, 0x67, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x73, 0x65, 0x61, 0x72,
	0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x4d, 0x61,
	0x74, 0x63, 0x68, 0x2e, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x53, 0x74, 0x72, 0x69, 0x6e,
	0x67, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x3a, 0x0a, 0x04, 0x64, 0x69,
	0x66, 0x66, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63,
	0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x4d, 0x61, 0x74,
	0x63, 0x68, 0x2e, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67,
	0x52, 0x04, 0x64, 0x69, 0x66, 0x66, 0x12, 0x25, 0x0a, 0x0e, 0x6d, 0x6f, 0x64, 0x69, 0x66, 0x69,
	0x65, 0x64, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x73, 0x18, 0x09, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0d,
	0x6d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x46, 0x69, 0x6c, 0x65, 0x73, 0x1a, 0x65, 0x0a,
	0x09, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61,
	0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x14,
	0x0a, 0x05, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65,
	0x6d, 0x61, 0x69, 0x6c, 0x12, 0x2e, 0x0a, 0x04, 0x64, 0x61, 0x74, 0x65, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
	0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x04,
	0x64, 0x61, 0x74, 0x65, 0x1a, 0x61, 0x0a, 0x0d, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x53,
	0x74, 0x72, 0x69, 0x6e, 0x67, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x12,
	0x36, 0x0a, 0x06, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x1e, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f,
	0x6d, 0x6d, 0x69, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x52,
	0x06, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x1a, 0x75, 0x0a, 0x05, 0x52, 0x61, 0x6e, 0x67, 0x65,
	0x12, 0x37, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x21, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f,
	0x6d, 0x6d, 0x69, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x2e, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x52, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x12, 0x33, 0x0a, 0x03, 0x65, 0x6e, 0x64,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65,
	0x72, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68,
	0x2e, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x03, 0x65, 0x6e, 0x64, 0x1a, 0x4e,
	0x0a, 0x08, 0x4c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x16, 0x0a, 0x06, 0x6f, 0x66,
	0x66, 0x73, 0x65, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x6f, 0x66, 0x66, 0x73,
	0x65, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x6c, 0x69, 0x6e, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x04, 0x6c, 0x69, 0x6e, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x63, 0x6f, 0x6c, 0x75, 0x6d, 0x6e,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x63, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x2a, 0x71,
	0x0a, 0x0c, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x4b, 0x69, 0x6e, 0x64, 0x12, 0x1d,
	0x0a, 0x19, 0x4f, 0x50, 0x45, 0x52, 0x41, 0x54, 0x4f, 0x52, 0x5f, 0x4b, 0x49, 0x4e, 0x44, 0x5f,
	0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x15, 0x0a,
	0x11, 0x4f, 0x50, 0x45, 0x52, 0x41, 0x54, 0x4f, 0x52, 0x5f, 0x4b, 0x49, 0x4e, 0x44, 0x5f, 0x41,
	0x4e, 0x44, 0x10, 0x01, 0x12, 0x14, 0x0a, 0x10, 0x4f, 0x50, 0x45, 0x52, 0x41, 0x54, 0x4f, 0x52,
	0x5f, 0x4b, 0x49, 0x4e, 0x44, 0x5f, 0x4f, 0x52, 0x10, 0x02, 0x12, 0x15, 0x0a, 0x11, 0x4f, 0x50,
	0x45, 0x52, 0x41, 0x54, 0x4f, 0x52, 0x5f, 0x4b, 0x49, 0x4e, 0x44, 0x5f, 0x4e, 0x4f, 0x54, 0x10,
	0x03, 0x32, 0xb7, 0x01, 0x0a, 0x0f, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x53, 0x65,
	0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x48, 0x0a, 0x06, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x12,
	0x1a, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x65,
	0x61, 0x72, 0x63, 0x68, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1b, 0x2e, 0x73, 0x65,
	0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x03, 0x90, 0x02, 0x02, 0x30, 0x01, 0x12,
	0x5a, 0x0a, 0x0c, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x12,
	0x20, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f,
	0x6d, 0x6d, 0x69, 0x74, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x1a, 0x21, 0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x76, 0x31, 0x2e,
	0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x22, 0x03, 0x90, 0x02, 0x01, 0x30, 0x01, 0x42, 0x39, 0x5a, 0x37, 0x67,
	0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65,
	0x67, 0x72, 0x61, 0x70, 0x68, 0x2f, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x67, 0x72, 0x61, 0x70,
	0x68, 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x2f, 0x73, 0x65, 0x61, 0x72, 0x63,
	0x68, 0x65, 0x72, 0x2f, 0x76, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_searcher_proto_rawDescOnce sync.Once
	file_searcher_proto_rawDescData = file_searcher_proto_rawDesc
)

func file_searcher_proto_rawDescGZIP() []byte {
	file_searcher_proto_rawDescOnce.Do(func() {
		file_searcher_proto_rawDescData = protoimpl.X.CompressGZIP(file_searcher_proto_rawDescData)
	})
	return file_searcher_proto_rawDescData
}

var file_searcher_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_searcher_proto_msgTypes = make([]protoimpl.MessageInfo, 30)
var file_searcher_proto_goTypes = []interface{}{
	(OperatorKind)(0),                 // 0: searcher.v1.OperatorKind
	(*SearchRequest)(nil),             // 1: searcher.v1.SearchRequest
	(*SearchResponse)(nil),            // 2: searcher.v1.SearchResponse
	(*FileMatch)(nil),                 // 3: searcher.v1.FileMatch
	(*ChunkMatch)(nil),                // 4: searcher.v1.ChunkMatch
	(*Range)(nil),                     // 5: searcher.v1.Range
	(*Location)(nil),                  // 6: searcher.v1.Location
	(*QueryNode)(nil),                 // 7: searcher.v1.QueryNode
	(*PatternNode)(nil),               // 8: searcher.v1.PatternNode
	(*AndNode)(nil),                   // 9: searcher.v1.AndNode
	(*OrNode)(nil),                    // 10: searcher.v1.OrNode
	(*PatternInfo)(nil),               // 11: searcher.v1.PatternInfo
	(*CommitSearchRequest)(nil),       // 12: searcher.v1.CommitSearchRequest
	(*RevisionSpecifier)(nil),         // 13: searcher.v1.RevisionSpecifier
	(*AuthorMatchesNode)(nil),         // 14: searcher.v1.AuthorMatchesNode
	(*CommitterMatchesNode)(nil),      // 15: searcher.v1.CommitterMatchesNode
	(*CommitBeforeNode)(nil),          // 16: searcher.v1.CommitBeforeNode
	(*CommitAfterNode)(nil),           // 17: searcher.v1.CommitAfterNode
	(*MessageMatchesNode)(nil),        // 18: searcher.v1.MessageMatchesNode
	(*DiffMatchesNode)(nil),           // 19: searcher.v1.DiffMatchesNode
	(*DiffModifiesFileNode)(nil),      // 20: searcher.v1.DiffModifiesFileNode
	(*BooleanNode)(nil),               // 21: searcher.v1.BooleanNode
	(*CommitSearchOperatorNode)(nil),  // 22: searcher.v1.CommitSearchOperatorNode
	(*CommitSearchQueryNode)(nil),     // 23: searcher.v1.CommitSearchQueryNode
	(*CommitSearchResponse)(nil),      // 24: searcher.v1.CommitSearchResponse
	(*CommitMatch)(nil),               // 25: searcher.v1.CommitMatch
	(*SearchResponse_Done)(nil),       // 26: searcher.v1.SearchResponse.Done
	(*CommitMatch_Signature)(nil),     // 27: searcher.v1.CommitMatch.Signature
	(*CommitMatch_MatchedString)(nil), // 28: searcher.v1.CommitMatch.MatchedString
	(*CommitMatch_Range)(nil),         // 29: searcher.v1.CommitMatch.Range
	(*CommitMatch_Location)(nil),      // 30: searcher.v1.CommitMatch.Location
	(*durationpb.Duration)(nil),       // 31: google.protobuf.Duration
	(*timestamppb.Timestamp)(nil),     // 32: google.protobuf.Timestamp
}
var file_searcher_proto_depIdxs = []int32{
	11, // 0: searcher.v1.SearchRequest.pattern_info:type_name -> searcher.v1.PatternInfo
	31, // 1: searcher.v1.SearchRequest.fetch_timeout:type_name -> google.protobuf.Duration
	3,  // 2: searcher.v1.SearchResponse.file_match:type_name -> searcher.v1.FileMatch
	26, // 3: searcher.v1.SearchResponse.done_message:type_name -> searcher.v1.SearchResponse.Done
	4,  // 4: searcher.v1.FileMatch.chunk_matches:type_name -> searcher.v1.ChunkMatch
	6,  // 5: searcher.v1.ChunkMatch.content_start:type_name -> searcher.v1.Location
	5,  // 6: searcher.v1.ChunkMatch.ranges:type_name -> searcher.v1.Range
	6,  // 7: searcher.v1.Range.start:type_name -> searcher.v1.Location
	6,  // 8: searcher.v1.Range.end:type_name -> searcher.v1.Location
	8,  // 9: searcher.v1.QueryNode.pattern:type_name -> searcher.v1.PatternNode
	9,  // 10: searcher.v1.QueryNode.and:type_name -> searcher.v1.AndNode
	10, // 11: searcher.v1.QueryNode.or:type_name -> searcher.v1.OrNode
	7,  // 12: searcher.v1.AndNode.children:type_name -> searcher.v1.QueryNode
	7,  // 13: searcher.v1.OrNode.children:type_name -> searcher.v1.QueryNode
	7,  // 14: searcher.v1.PatternInfo.query:type_name -> searcher.v1.QueryNode
	13, // 15: searcher.v1.CommitSearchRequest.revisions:type_name -> searcher.v1.RevisionSpecifier
	23, // 16: searcher.v1.CommitSearchRequest.query:type_name -> searcher.v1.CommitSearchQueryNode
	32, // 17: searcher.v1.CommitBeforeNode.timestamp:type_name -> google.protobuf.Timestamp
	32, // 18: searcher.v1.CommitAfterNode.timestamp:type_name -> google.protobuf.Timestamp
	0,  // 19: searcher.v1.CommitSearchOperatorNode.kind:type_name -> searcher.v1.OperatorKind
	23, // 20: searcher.v1.CommitSearchOperatorNode.operands:type_name -> searcher.v1.CommitSearchQueryNode
	14, // 21: searcher.v1.CommitSearchQueryNode.author_matches:type_name -> searcher.v1.AuthorMatchesNode
	15, // 22: searcher.v1.CommitSearchQueryNode.committer_matches:type_name -> searcher.v1.CommitterMatchesNode
	16, // 23: searcher.v1.CommitSearchQueryNode.commit_before:type_name -> searcher.v1.CommitBeforeNode
	17, // 24: searcher.v1.CommitSearchQueryNode.commit_after:type_name -> searcher.v1.CommitAfterNode
	18, // 25: searcher.v1.CommitSearchQueryNode.message_matches:type_name -> searcher.v1.MessageMatchesNode
	19, // 26: searcher.v1.CommitSearchQueryNode.diff_matches:type_name -> searcher.v1.DiffMatchesNode
	20, // 27: searcher.v1.CommitSearchQueryNode.diff_modifies_file:type_name -> searcher.v1.DiffModifiesFileNode
	21, // 28: searcher.v1.CommitSearchQueryNode.boolean:type_name -> searcher.v1.BooleanNode
	22, // 29: searcher.v1.CommitSearchQueryNode.operator:type_name -> searcher.v1.CommitSearchOperatorNode
	25, // 30: searcher.v1.CommitSearchResponse.match:type_name -> searcher.v1.CommitMatch
	27, // 31: searcher.v1.CommitMatch.author:type_name -> searcher.v1.CommitMatch.Signature
	27, // 32: searcher.v1.CommitMatch.committer:type_name -> searcher.v1.CommitMatch.Signature
	28, // 33: searcher.v1.CommitMatch.message:type_name -> searcher.v1.CommitMatch.MatchedString
	28, // 34: searcher.v1.CommitMatch.diff:type_name -> searcher.v1.CommitMatch.MatchedString
	32, // 35: searcher.v1.CommitMatch.Signature.date:type_name -> google.protobuf.Timestamp
	29, // 36: searcher.v1.CommitMatch.MatchedString.ranges:type_name -> searcher.v1.CommitMatch.Range
	30, // 37: searcher.v1.CommitMatch.Range.start:type_name -> searcher.v1.CommitMatch.Location
	30, // 38: searcher.v1.CommitMatch.Range.end:type_name -> searcher.v1.CommitMatch.Location
	1,  // 39: searcher.v1.SearcherService.Search:input_type -> searcher.v1.SearchRequest
	12, // 40: searcher.v1.SearcherService.CommitSearch:input_type -> searcher.v1.CommitSearchRequest
	2,  // 41: searcher.v1.SearcherService.Search:output_type -> searcher.v1.SearchResponse
	24, // 42: searcher.v1.SearcherService.CommitSearch:output_type -> searcher.v1.CommitSearchResponse
	41, // [41:43] is the sub-list for method output_type
	39, // [39:41] is the sub-list for method input_type
	39, // [39:39] is the sub-list for extension type_name
	39, // [39:39] is the sub-list for extension extendee
	0,  // [0:39] is the sub-list for field type_name
}

func init() { file_searcher_proto_init() }
func file_searcher_proto_init() {
	if File_searcher_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_searcher_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SearchRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SearchResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FileMatch); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ChunkMatch); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Range); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Location); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*QueryNode); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PatternNode); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AndNode); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*OrNode); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PatternInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CommitSearchRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RevisionSpecifier); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AuthorMatchesNode); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CommitterMatchesNode); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CommitBeforeNode); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CommitAfterNode); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MessageMatchesNode); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DiffMatchesNode); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DiffModifiesFileNode); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BooleanNode); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CommitSearchOperatorNode); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CommitSearchQueryNode); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[23].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CommitSearchResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[24].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CommitMatch); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[25].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SearchResponse_Done); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[26].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CommitMatch_Signature); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[27].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CommitMatch_MatchedString); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[28].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CommitMatch_Range); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_searcher_proto_msgTypes[29].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CommitMatch_Location); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_searcher_proto_msgTypes[1].OneofWrappers = []interface{}{
		(*SearchResponse_FileMatch)(nil),
		(*SearchResponse_DoneMessage)(nil),
	}
	file_searcher_proto_msgTypes[6].OneofWrappers = []interface{}{
		(*QueryNode_Pattern)(nil),
		(*QueryNode_And)(nil),
		(*QueryNode_Or)(nil),
	}
	file_searcher_proto_msgTypes[22].OneofWrappers = []interface{}{
		(*CommitSearchQueryNode_AuthorMatches)(nil),
		(*CommitSearchQueryNode_CommitterMatches)(nil),
		(*CommitSearchQueryNode_CommitBefore)(nil),
		(*CommitSearchQueryNode_CommitAfter)(nil),
		(*CommitSearchQueryNode_MessageMatches)(nil),
		(*CommitSearchQueryNode_DiffMatches)(nil),
		(*CommitSearchQueryNode_DiffModifiesFile)(nil),
		(*CommitSearchQueryNode_Boolean)(nil),
		(*CommitSearchQueryNode_Operator)(nil),
	}
	file_searcher_proto_msgTypes[23].OneofWrappers = []interface{}{
		(*CommitSearchResponse_Match)(nil),
		(*CommitSearchResponse_LimitHit)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_searcher_proto_rawDesc,
			NumEnums:      1,
			NumMessages:   30,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_searcher_proto_goTypes,
		DependencyIndexes: file_searcher_proto_depIdxs,
		EnumInfos:         file_searcher_proto_enumTypes,
		MessageInfos:      file_searcher_proto_msgTypes,
	}.Build()
	File_searcher_proto = out.File
	file_searcher_proto_rawDesc = nil
	file_searcher_proto_goTypes = nil
	file_searcher_proto_depIdxs = nil
}
